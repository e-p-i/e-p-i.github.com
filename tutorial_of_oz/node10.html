<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>10 Classes and Objects</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html#chapter.stateful">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node11.html#chapter.objectscc">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.classes"><H1><A name="chapter.classes">10 Classes and Objects</A></H1><P>Oz のクラスは次のものを含んでいます: </P><UL><LI><P>メソッドテーブルのメソッドのコレクション。 </P></LI><LI><P>クラスの各インスタンスが所有する属性(attribute)の記述。各属性は属性の名前によってアクセス出来るステートフルなセルで、アトムか Oz-name のどちらかです。 </P></LI><LI><P>クラスの各インスタンスが所有するフィールド名の記述。フィールドはフィールド名でアクセス出来る代入不可のコンポーネント(変数)で、アトムか Oz-name のどちらかです。 </P></LI><LI><P>クラスはステートレスな Oz の値です<A href="node10.html#label57"><SUP>1</SUP></A>。Smalltalk, Java その他の言語と対照的に、それらはクラスのオブジェクトがどの様に振る舞うべきかを記述したものにすぎません。 </P></LI></UL><P> </P><DIV id="section.classes.classprinciples"><H2><A name="section.classes.classprinciples">10.1第一原理からのクラス</A></H2><P><A href="node10.html#classconstr">Figure&nbsp;10.1</A> は上の筋書きに沿った第一原理からどの様にクラスが構築されるかを示しています。ここで私達は <CODE>Counter</CODE> クラスを構築します。それはアトム val によってアクセスされる単一の属性を持ちます。それはメソッドテーブルを持ち、それはチャンクのフィールド名を通してアクセスされる3つのメソッド <CODE>browse</CODE>, <CODE>init</CODE>, <CODE>inc</CODE> を持ちます。メソッドは、常にレコードである、現在のオブジェクトの状態を表し内部的に <CODE><SPAN class="keyword">self</SPAN></CODE> として知られている追加のパラメータであるメッセージを取る、手続きです。 </P><P></P><DIV class="figure" id="classconstr"><HR><P><A name="classconstr"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Counter<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Attrs&nbsp;=&nbsp;[val]<BR>&nbsp;&nbsp;&nbsp;MethodTable&nbsp;=&nbsp;m(browse:MyBrowse&nbsp;init:Init&nbsp;inc:Inc)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Init</SPAN>&nbsp;M&nbsp;S&nbsp;Self}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init(Value)&nbsp;=&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(S<SPAN class="keyword">.</SPAN>val)&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Value<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Inc</SPAN>&nbsp;M&nbsp;S&nbsp;Self}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;inc(Value)=M<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>(S<SPAN class="keyword">.</SPAN>val)&nbsp;(S<SPAN class="keyword">.</SPAN>val)&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<SPAN class="keyword">+</SPAN>Value&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MyBrowse</SPAN>&nbsp;M=browse&nbsp;S&nbsp;Self}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>(S<SPAN class="keyword">.</SPAN>val)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Counter&nbsp;=&nbsp;{NewChunk&nbsp;c(methods:MethodTable&nbsp;attrs:Attrs)}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.1:</STRONG> クラス構築の例</P><HR></DIV><P> </P><P> あなたはメソッド <CODE>init</CODE> が属性 <CODE>val</CODE> を値 <CODE>Value</CODE> に割り当て、メソッド <CODE>inc</CODE> が属性 <CODE>val</CODE> を増加させ、メソッド <CODE>browse</CODE> が <CODE>val</CODE> の現在の値をブラウズする事を見る事が出来るでしょう。 </P></DIV><DIV id="section.classes.objectprinciples"><H2><A name="section.classes.objectprinciples">10.2第一原理からのオブジェクト</A></H2><P><A href="node10.html#objectconstr">Figure&nbsp;10.2</A> は与えられたクラスからオブジェクトを生成するジェネリックな手続きを示します。この手続きはクラスの属性からオブジェクトを生成します。これはオブジェクトの属性を、それぞれセルとして(初期値は未束縛なものとして)初期化します。ここで私達は、レコードの全フィールドを反復する反復子 <CODE>Record<SPAN class="keyword">.</SPAN>forAll<SPAN class="keyword">/</SPAN>2</CODE> を使います。<CODE>NewObject</CODE> はオブジェクトを特定する手続き <CODE>Object</CODE> を返します。オブジェクトの状態は <CODE>Object</CODE> の中でのみ可視である事に注視して下さい。ある人は <CODE>Object</CODE> は状態をカプセル化した手続きだと言うかもしれません <A href="node10.html#label58"><SUP>2</SUP></A>。(訳注:これはLisp族での環境を伴った関数定義を想定しているのでしょう) </P><P></P><DIV class="figure" id="objectconstr"><HR><P><A name="objectconstr"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewObject</SPAN>&nbsp;Class&nbsp;InitialMethod&nbsp;?Object}<BR>&nbsp;&nbsp;&nbsp;State&nbsp;O<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;State&nbsp;=&nbsp;{MakeRecord&nbsp;s&nbsp;Class<SPAN class="keyword">.</SPAN>attrs}<BR>&nbsp;&nbsp;&nbsp;{Record<SPAN class="keyword">.</SPAN>forAll&nbsp;State&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;A}&nbsp;{NewCell&nbsp;_&nbsp;A}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">O</SPAN>&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Class<SPAN class="keyword">.</SPAN>methods<SPAN class="keyword">.</SPAN>{Label&nbsp;M}&nbsp;M&nbsp;State&nbsp;O}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{O&nbsp;InitialMethod}<BR>&nbsp;&nbsp;&nbsp;Object&nbsp;=&nbsp;O<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.2:</STRONG> オブジェクトの構築</P><HR></DIV><P> </P><P>私達は以下の様にプログラムを試してみる事が出来ます </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;C<BR>{NewObject&nbsp;Counter&nbsp;init(0)&nbsp;C}<BR>{C&nbsp;inc(6)}&nbsp;{C&nbsp;inc(6)}<BR>{C&nbsp;browse}</CODE></BLOCKQUOTE><P> </P><P>以下の文を実行してみて下さい。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{C&nbsp;inc(X)}&nbsp;X=5&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;{C&nbsp;browse}</CODE></BLOCKQUOTE><P> </P><P>何も起こらない事が見て取れるでしょう。その理由はオブジェクトの適用 </P><BLOCKQUOTE class="code"><CODE>{C&nbsp;inc(X)}</CODE></BLOCKQUOTE><P> </P><P>がメソッド <CODE>inc</CODE> を実装している手続き <CODE>Inc<SPAN class="keyword">/</SPAN>3</CODE> の内部で一時停止するからです。それがどこだか正確に分かりますか？他方、以下の文の実行では、期待される様に働きます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{C&nbsp;inc(X)}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;X=5&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;{C&nbsp;browse}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.forreal"><H2><A name="section.classes.forreal">10.3実際のオブジェクトとクラス</A></H2><P>Oz は上で筋書きが書かれた方法論に従って、オブジェクト指向プログラミングをサポートします。構文サポートと最適化された実装もあり、オブジェクトの適用(オブジェクト中のメソッド呼び出しによる)も手続きの呼び出しと同じくらい安価です。先に定義されたクラス <CODE>Counter</CODE> は <A href="node10.html#counterclass">Figure&nbsp;10.3</A> で示される様な構文形式を持っています: </P><P></P><DIV class="figure" id="counterclass"><HR><P><A name="counterclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Counter</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;val<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">browse</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>val}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">inc</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>val&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;Value<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Value<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.3:</STRONG> Counter クラス</P><HR></DIV><P> </P><P>クラス <I>X</I> は次によって定義されます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;</CODE><I>X</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>属性はメソッド宣言部の前の属性宣言部を使って定義されます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">attr</SPAN>&nbsp;</CODE><I>A1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>AN</I></BLOCKQUOTE><P> </P><P>そしてメソッド定義が続きます、それらは次の形式を持っています: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="functionname">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>式 <I>E</I> がメソッドの頭部として評価される時、それはそのラベルがメソッド名であるレコードです。属性 <I>A</I> は式 <CODE><SPAN class="keyword">@</SPAN></CODE><I>A</I> を使ってアクセスされます。値の割り当ては文 <I>A</I><CODE>&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;</CODE><I>E</I> を使って行われます。 </P><P>クラスは次の様に匿名的に定義する事も出来ます: </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>以下は、オブジェクトがクラスから手続き <CODE>New<SPAN class="keyword">/</SPAN>3</CODE> を使ってどの様に生成されるかを示しています、その最初の引数はクラスで、2番目は初期化メソッドで結果はオブジェクトです。<CODE>New<SPAN class="keyword">/</SPAN>3</CODE> はクラスからオブジェクトを生成するためのジェネリックな手続きです。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;C&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>C&nbsp;=&nbsp;{New&nbsp;Counter&nbsp;init(0)}<BR>{C&nbsp;browse}<BR>{C&nbsp;inc(1)}<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{C&nbsp;inc(X)}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;X=5&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label53">10.3.1静的メソッド(static method)の呼び出し</A></H3><P>クラス <I>C</I> があってメソッド頭部 <I>m</I><CODE>(<SPAN class="keyword">...</SPAN>)</CODE> が以下の形式を持つメソッド呼び出しだとします: </P><BLOCKQUOTE class="code"><I>C</I><CODE><SPAN class="keyword">,</SPAN>&nbsp;</CODE><I>m</I><CODE>(<SPAN class="keyword">...</SPAN>)</CODE></BLOCKQUOTE><P> </P><P>メソッド呼び出しはクラスの引数で定義されたメソッドを呼び出します。メソッド呼び出しはメソッド定義の中でのみ使う事が出来ます。これがメソッド呼び出しが <CODE><SPAN class="keyword">self</SPAN></CODE> で示される現在のオブジェクトを暗黙の引数として取る理由です。メソッドはクラス <CODE>C</CODE> かまたはその親クラスから継承してきたもので定義する事が出来ます。継承は手短に説明されます。 </P><H3><A name="label54">10.3.2モジュールとしてのクラス</A></H3><P>静的メソッドの呼び出しは一般的に手続き呼び出しと同じ効率を持っています。これはクラスにモジュールの仕様として使われる事を許します。これはクラスが継承によって段階的に構築可能である事による優位性かもしれません。<A href="node10.html#listclass">Figure&nbsp;10.4</A> に示されるプログラムはクラスがモジュールの仕様として振る舞える事を示しています。クラス <CODE>ListC</CODE> はメソッドとしていくつかの共通のリスト手続きを定義しています。<CODE>ListC</CODE> はメソッド <CODE>append<SPAN class="keyword">/</SPAN>3</CODE>, <CODE>member<SPAN class="keyword">/</SPAN>2</CODE>, <CODE>length<SPAN class="keyword">/</SPAN>2</CODE>, <CODE>nrev<SPAN class="keyword">/</SPAN>2</CODE> を定義しています。メソッド本体部が Oz 文と似ていて、しかしメソッド呼び出しも許されている事を注視して下さい。私達はここで継承の最初の例も見ます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ListC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN></CODE></BLOCKQUOTE><P> 私達は関数的メソッド、すなわち関数に似た結果を返すメソッドもお見せします。関数的メソッドは一般に以下の様な形式を持っています: </P><BLOCKQUOTE class="code"><CODE>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;$)&nbsp;S&nbsp;E&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;</CODE></BLOCKQUOTE><P> </P><P>ここでクラス <CODE>ListC</CODE> は事前に定義されたクラス <CODE>BaseObject</CODE> (自明なメソッド <CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">noop</SPAN>()&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> を持つ)を継承しています。 </P><P></P><DIV class="figure" id="listclass"><HR><P><A name="listclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ListC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">append</SPAN>(Xs&nbsp;Ys&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ys<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">|</SPAN>(ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;append(Xr&nbsp;Ys&nbsp;$))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">member</SPAN>(X&nbsp;L&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Member&nbsp;X&nbsp;L}&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;これは List.oz で定義されています<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">length</SPAN>(Xs&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;_<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;length(Xr&nbsp;$))&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">nrev</SPAN>(Xs&nbsp;?Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ys&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Yr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;nrev(Xr&nbsp;Yr)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;append(Yr&nbsp;[X]&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.4:</STRONG> List クラス</P><HR></DIV><P> </P><P>モジュール仕様からモジュールを生成するのは、クラスからオブジェクトを生成する事を必要とします。これは次によって行われます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;ListM&nbsp;=&nbsp;{New&nbsp;ListC&nbsp;noop}</CODE></BLOCKQUOTE><P> </P><P><CODE>ListM</CODE> はモジュールとしての役割を果たすオブジェクトです、すなわち、それは手続き(メソッド)の群をカプセル化します。私達はこのモジュールをいくつかのメソッド呼び出しを行う事によって試す事が出来ます: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{ListM&nbsp;append([1&nbsp;2&nbsp;3]&nbsp;[4&nbsp;5]&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{ListM&nbsp;length([1&nbsp;2&nbsp;3]&nbsp;&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{ListM&nbsp;nrev([1&nbsp;2&nbsp;3]&nbsp;&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.inheritance"><H2><A name="section.classes.inheritance">10.4継承(inheritance)</A></H2><P>クラスは次のキーワードの後に見える1つまたはいくつかのクラスを継承するかもしれません: <CODE><SPAN class="keyword">from</SPAN></CODE>クラス <I>B</I> は <I>A</I> の <EM>親クラス(superclass)</EM> です、もし: </P><UL><LI><P><I>B</I> が <I>A</I> の宣言で <CODE><SPAN class="keyword">from</SPAN></CODE> 中に表れるならば、または </P></LI><LI><P><I>B</I> が <I>A</I> の宣言で <CODE><SPAN class="keyword">from</SPAN></CODE> 中に表れるクラスの親クラスであるならば。 </P></LI></UL><P> </P><P>継承は既存のクラスから新しいクラスを構築する手段です。それはどんな属性、フィールド名<A href="node10.html#label59"><SUP>3</SUP></A>、メソッドが新しいクラスで利用できるのかを定義します。継承の話をメソッドに限定しましょう。なお、同じルールがフィールド名と属性にも適用できます。 </P><P>クラス <I>C</I> で利用可能なメソッド(つまり可視なもの)はクラス階層で見られるメソッドに優先的に関係しています。私達はこの関係を<EM>オーバーライド関係(overriding relation)</EM>と呼びます: </P><UL><LI><P>クラス <I>C</I> のメソッドは親クラス <I>C</I> の同じラベルのどのメソッドもオーバーライドします。 </P></LI></UL><P> </P><P>親クラス関係のクラス階層はルートで定義されたクラスによって有向グラフに見えます。辺はサブクラスを指しています。継承が適正であるために2つの要求があります。最初は、継承関係は方向付けられていて非循環という事です。それゆえ、以下は許可されません: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;B</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="cycle"><HR><P><A name="cycle"></A></P></DIV><DIV align="center"><IMG alt="" src="image161.gif"></DIV><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.5:</STRONG> 不正なクラス階層</P><HR></DIV><P> </P><P>2番目は、全てのオーバーライドされたメソッドを退去させた後、階層中のクラスの中において残ったメソッドはユニークなラベルを持っていてかつ定義されているという事です。それゆえ、以下の例のクラス <CODE>C</CODE> は2つのラベル <CODE>m</CODE> が残っているので不正です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A1</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B1</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;B1</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A1</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A&nbsp;B</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="illegalclassinheritance"><HR><P><A name="illegalclassinheritance"></A></P></DIV><DIV align="center"><IMG alt="" src="inheritance1.gif"></DIV><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.6:</STRONG> メソッド <CODE>m</CODE> で不正なクラス</P><HR></DIV><P> </P><P>下のクラス <CODE>C</CODE> も2つのメソッド <CODE>m</CODE> が <CODE>C</CODE> 中で利用可能なので不正です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A&nbsp;B</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>あなたが不正な階層を持つプログラムを走らせると、システムは不正なメソッドにアクセスしようとしたオブジェクトが作られるまで文句を言わないでしょう。この時点になって、あなたは実行時エラーを得るでしょう。その理由は、クラスはコンパイル時に個別に形作られ、実行時にメソッドキャッシュを使って要求によって完成するからです。 </P><H3><A name="label55">10.4.1多重継承(multiple inheritance)か否か</A></H3><P>私の意見は以下です: </P><UL><LI><P>一般的に、多重継承の使用を適正に行うには、使用者は全ての継承階層を理解し、それは時たま努力に見合う価値がある。これは共通の祖先がある時に重要です。 </P></LI><LI><P>Oz は多重継承をそれにまつわる問題の多くが起こらないように制限しています。 </P></LI><LI><P>Oz は使用者に1つより多くの親クラスで定義されているメソッドのオーバーライドを要求し、ローカルで競合するメソッドの内でどれをオーバーロードするか定義しなければならないという、プログラミングの方法論を強制します。 </P></LI><LI><P>多重継承には兄弟(sibling)親クラスが直接的間接的に共通のステートフル(つまり属性を持つ)な祖先クラスを共有している時にも問題があります。ある者は同じ属性に対する操作の複製を得るかもしれません。これはクラスにおいて初期化メソッドの実行時に典型的に起きるもので、親クラスの初期化をしなくてはなりません。ここでの唯一の対処法は注意深く継承階層を理解してその様な複製を避ける事です。別の方法は、ステートフルな共通の祖先を共有していない複数のクラスのみを継承する事です。このプログラムは実装共有問題として知られています。 </P></LI></UL><P> </P></DIV><DIV id="section.classes.features"><H2><A name="section.classes.features">10.5フィールド名(feature)</A></H2><P>オブジェクトはレコードに似たフィールド名を持っているかもしれません。フィールド名はクラス宣言時に指定されるステートレスなコンポーネントです: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;</CODE><I>C</I><CODE>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;</CODE><I>A1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>AN</I><CODE>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>レコードの様に、オブジェクトのフィールド名は対応するフィールドを持っています。フィールドは Oz の値(セル、オブジェクト、クラスetc)に束縛されうる論理変数です。オブジェクトのフィールド名は中置演算子 '<CODE><SPAN class="keyword">.</SPAN></CODE>' を使ってアクセスされます。以下はフィールド名の使用例です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ApartmentC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">AptC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;ApartmentC</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;streetName:&nbsp;york<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;streetNumber:100<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallColor:white<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floorSurface:wood<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label56">10.5.1フィールドの初期化</A></H3><P>例はクラス定義時にどの様にフィールドが初期化されるかを示します。このケースでは、クラス <CODE>AptC</CODE> の全インスタンスがクラスのフィールド名を対応する値とともに持つでしょう。それゆえ、以下のプログラムは <CODE>york</CODE> を2回表示するでしょう。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Apt1&nbsp;Apt2<BR>Apt1&nbsp;=&nbsp;{New&nbsp;AptC&nbsp;init}<BR>Apt2&nbsp;=&nbsp;{New&nbsp;AptC&nbsp;init}<BR>{Browse&nbsp;Apt1<SPAN class="keyword">.</SPAN>streetName}<BR>{Browse&nbsp;Apt2<SPAN class="keyword">.</SPAN>streetName}</CODE></BLOCKQUOTE><P> </P><P>私達は次の様にフィールドを初期化しないまま去る事も出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">MyAptC1</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;ApartmentC</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;streetName<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>この場合、どんなインスタンスが生成されても、フィールド名のフィールドは新しい未使用の論理変数が割り当てられます。それゆえ、以下のプログラムはオブジェクト <CODE>Apt3</CODE> のフィールド名 <CODE>streetName</CODE> をアトム <CODE>kungsgatan</CODE> に束縛し、対応するフィールド名 <CODE>Apt4</CODE> をアトム <CODE>sturegatan</CODE> に束縛します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Apt3&nbsp;Apt4<BR>Apt3&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>Apt4&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>Apt3<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;kungsgatan<BR>Apt4<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;sturegatan</CODE></BLOCKQUOTE><P> </P><P>1つより多くの初期化が利用可能です。クラス定義のフィールドは変数または変数を持つ Oz の値に初期化出来ます。以下では、フィールドは匿名変数のタプルに初期化されます。この場合、クラスの全てのインスタンスは同じ変数を<EM>共有(share)</EM>します。以下のプログラムについて考えましょう。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">MyAptC1</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;ApartmentC</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;streetName:f(_)<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;Apt1&nbsp;Apt2&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>Apt1&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>Apt2&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>{Browse&nbsp;Apt1<SPAN class="keyword">.</SPAN>streetName}<BR>{Browse&nbsp;Apt2<SPAN class="keyword">.</SPAN>streetName}<BR>Apt1<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;f(york)</CODE></BLOCKQUOTE><P> </P><P>段階的に入力すると、文 </P><BLOCKQUOTE class="code"><CODE>Apt1<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;f(york)</CODE></BLOCKQUOTE><P> </P><P>が対応する <CODE>Apt2</CODE> のフィールド名を <CODE>Apt1</CODE> の同じ値に束縛するのが見えるでしょう。 </P><P> フィールド名について言った事は属性にも当てはまります。 </P></DIV><DIV id="section.classes.parametrized"><H2><A name="section.classes.parametrized">10.6パラメータ化されたクラス</A></H2><P>あなたのクラスをより汎用的(generic)にする多くの手段があります、それは後で特定の目的に特化(specialize)する事が出来ます。オブジェクト指向プログラミングでこれを行う共通の方法はまず最初にいくつかのメソッドが未指定で残されている<EM>抽象クラス(abstract class)</EM>を定義する事です。後でこれらのメソッドはサブクラスで定義されます。比較演算子 <CODE>less</CODE> を必要とするソートのための汎用クラスを定義したと想定して下さい。この演算子はどの種のデータがソートされるのかに依存します。整数、有理数、複素数etcのために異なる具象化が必要とされます。この場合、サブクラス化する事によって抽象クラスを<EM>実体(concrete)</EM> クラスに特化出来ます。 </P><P>Oz では、私達はジェネリッククラスを生成するための他の自然なメソッドも持っています。クラスは第一級の値(first-class value)であるので、私達は代わりにいくつかの型引数を取って型に特化されたクラスを返す関数を定義する事が出来ます。<A href="node10.html#paramclass">Figure&nbsp;10.7</A> では、クラスを単一の引数として取って引数のために特化したソートクラスを返す関数 <CODE>SortClass</CODE> が定義されています。 </P><P></P><DIV class="figure" id="paramclass"><HR><P><A name="paramclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SortClass</SPAN>&nbsp;Type}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">qsort</SPAN>(Xs&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ys&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;P<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;S&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;S&nbsp;L)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListC<SPAN class="keyword">,</SPAN>&nbsp;append({<SPAN class="keyword">self</SPAN>&nbsp;qsort(S&nbsp;$)}&nbsp;P<SPAN class="keyword">|</SPAN>{<SPAN class="keyword">self</SPAN>&nbsp;qsort(L&nbsp;$)}&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">partition</SPAN>(Xs&nbsp;P&nbsp;Ss&nbsp;Ls)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ss&nbsp;=&nbsp;nil&nbsp;Ls&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Sr&nbsp;Lr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Type<SPAN class="keyword">,</SPAN>less(X&nbsp;P&nbsp;$)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ss&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Sr&nbsp;Lr&nbsp;=&nbsp;Ls<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ss&nbsp;=&nbsp;Sr&nbsp;Ls&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Lr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;Sr&nbsp;Lr)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.7:</STRONG> パラメータ化されたクラス</P><HR></DIV><P> </P><P>私達は今、整数と有理数のために2つのクラスを定義出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Int</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">less</SPAN>(X&nbsp;Y&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">&lt;</SPAN>Y<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Rat</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Object</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">less</SPAN>(X&nbsp;Y&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="string">'/'</SPAN>(P&nbsp;Q)&nbsp;=&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="string">'/'</SPAN>(R&nbsp;S)&nbsp;=&nbsp;Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P<SPAN class="keyword">*</SPAN>S&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;Q<SPAN class="keyword">*</SPAN>R<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>それゆえ、私達は以下の文を実行出来ます: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{{New&nbsp;{SortClass&nbsp;Int}&nbsp;noop}&nbsp;qsort([1&nbsp;2&nbsp;5&nbsp;3&nbsp;4]&nbsp;$)}}<BR>{Browse&nbsp;{{New&nbsp;{SortClass&nbsp;Rat}&nbsp;noop}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qsort([<SPAN class="string">'/'</SPAN>(23&nbsp;3)&nbsp;<SPAN class="string">'/'</SPAN>(34&nbsp;11)&nbsp;<SPAN class="string">'/'</SPAN>(47&nbsp;17)]&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.self"><H2><A name="section.classes.self">10.7自己適用(self application)</A></H2><P><A href="node10.html#paramclass">Figure&nbsp;10.7</A> のプログラムはメソッド <CODE>qsort</CODE> でオブジェクトの適用がキーワード <CODE><SPAN class="keyword">self</SPAN></CODE> を使って行われているのを示しています(下を見て下さい)。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">qsort</SPAN>(Xs&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;S&nbsp;L)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>ここで私達は用語<EM>オブジェクト適用(object-application)</EM>を一般的に知られる用語<EM>メッセージ送信(message sending)</EM>の代わりに使っています、なぜならメッセージ送信は Oz の様な並行言語ではミスリーディングだからです。私達が <CODE><SPAN class="keyword">self</SPAN></CODE> をオブジェクト指定の代わりに次の様に使う時 </P><BLOCKQUOTE class="code"><CODE>{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;S&nbsp;L)}</CODE></BLOCKQUOTE><P> </P><P>私達は動的に現在のオブジェクトで定義されている(利用可能な)メソッド <CODE>partition</CODE> を取り上げる事を意味します。その後、私達はオブジェクトを(手続きとして)メッセージに適用します。これは全てのオブジェクト指向言語に共通する動的束縛の形式です。 </P></DIV><DIV id="section.classes.attributes"><H2><A name="section.classes.attributes">10.8属性(attribute)</A></H2><P>私達は属性の記法に以前触れました。属性はオブジェクトで状態を持ち越します。属性はフィールド名の様に宣言されますが、キーワード <CODE><SPAN class="keyword">attr</SPAN></CODE> を代わりに使います。オブジェクトが生成される時、各属性は新しいセルがその値として割り当てられます。これらのセルはフィールドと同じ方法で初期化されます。実際の違いは属性がセルで、割り当て、再度割り当てと任意のアクセスが任意に可能であるという事にあります。しかしながら、属性はオブジェクトにプライベートなものです。外側から属性を操作する唯一の方法は、クラスの設計者に属性を操作するメソッドを書いてもらう事です。<A href="node10.html#pointclass">Figure&nbsp;10.8</A> で私達はクラス <CODE>Point</CODE> を定義します。属性 <CODE>x</CODE> と <CODE>y</CODE> は初期化メッセージが適用される前に0に初期化される事に注意して下さい。メソッド <CODE>move</CODE> は <CODE><SPAN class="keyword">自己適用(self-application)</SPAN></CODE>を内部で行っています。 </P><P></P><DIV class="figure" id="pointclass"><HR><P><A name="pointclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Point</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;x:0&nbsp;y:0<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;属性の更新<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">location</SPAN>(L)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;l(x:<SPAN class="keyword">@</SPAN>x&nbsp;y:<SPAN class="keyword">@</SPAN>y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;属性にアクセス<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">moveHorizontal</SPAN>(X)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">moveVertical</SPAN>(Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Y<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;moveHorizontal(X)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;moveVertical(Y)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;browser を仮想文字列モードに変更<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">"point&nbsp;at&nbsp;("</SPAN><SPAN class="keyword">#@</SPAN>x<SPAN class="keyword">#</SPAN><SPAN class="string">"&nbsp;,&nbsp;"</SPAN><SPAN class="keyword">#@</SPAN>y<SPAN class="keyword">#</SPAN><SPAN class="string">")\n"</SPAN>}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.8:</STRONG> クラス Point</P><HR></DIV><P> </P><P><CODE>Point</CODE> のインスタンス生成といくつかのメッセージの適用の試行: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;P<BR>P&nbsp;=&nbsp;{New&nbsp;Point&nbsp;init(2&nbsp;0)}<BR>{P&nbsp;display}<BR>{P&nbsp;move(3&nbsp;2)}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.private"><H2><A name="section.classes.private">10.9プライベート(private)とプロテクテッド(protected)なメソッド</A></H2><P>メソッドはリテラルの代わりに変数によってラベル付けされるかもしれません。これらのメソッドは次の様に、定義されたクラスで<EM>プライベート(private)</EM>です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">A</SPAN>(X)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">a</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;A(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">....</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>メソッド <CODE>A</CODE> はクラス <CODE>C</CODE> の中でのみ可視です。実際には上の記法は以下の展開された定義の略記法です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;A&nbsp;=&nbsp;{NewName}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="keyword">!</SPAN><SPAN class="functionname">A</SPAN>(X)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">a</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;A(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>A はクラス定義のレキシカルスコープで新しい名前に束縛されます。 </P><P>いくつかのオブジェクト指向言語はプロテクテッドメソッドの記法も持っています。メソッドが定義されたクラスまたはその子孫クラス、すなわちサブクラス、サブサブクラスetcでのみアクセス可能な時、メソッドは<EM>プロテクテッド(protected)</EM>です。Oz ではプロテクテッドなメソッドを定義する直接の方法はありません。しかしながら同じ効果を与えるプログラミングテクニックがあります。私達は属性が定義されたクラスまたはその継承による子孫クラスでのみ可視である事を知っています。私達はメソッドを最初にプライベートにして次にそれを属性にストアする事でプロテクテッドにする事が出来ます。以下の例を考えましょう: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;pa:A<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">A</SPAN>(X)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">a</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;A(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>今、私達は <CODE>C</CODE> のサブクラス <CODE>C1</CODE> と生成し、メソッド <CODE>A</CODE> に以下の様にアクセスします: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C1</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;C</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">b</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;L=<SPAN class="keyword">@</SPAN>pa&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;L(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>メソッド <CODE>b</CODE> はメソッド <CODE>A</CODE> に属性 <CODE>pa</CODE> を通してアクセスします。 </P><P> 前の移動の履歴を保存する点を加えるように特化されたクラスの定義によって <A href="node10.html#pointclass">Figure&nbsp;10.8</A> の簡単な例で続けましょう。これは <A href="node10.html#histpointclass">Figure&nbsp;10.9</A> で見られます。 </P><P></P><DIV class="figure" id="histpointclass"><HR><P><A name="histpointclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">HistoryPoint</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Point</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history:&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;displayHistory:&nbsp;DisplayHistory<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>init(X&nbsp;Y)&nbsp;&nbsp;<SPAN class="comment">%&nbsp;親クラスを呼び出します<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;[l(X&nbsp;Y)]<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>move(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;l(X&nbsp;Y)<SPAN class="keyword">|@</SPAN>history<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>display<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;DisplayHistory}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">DisplayHistory</SPAN>&nbsp;&nbsp;<SPAN class="comment">%&nbsp;プロテクテッドメソッドを作ります<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">"with&nbsp;location&nbsp;history:&nbsp;"</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>history}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.9:</STRONG> クラス History Point</P><HR></DIV><P> </P><P><CODE>HistoryPoint</CODE> のクラス定義にはいくつも言及すべき所があります。最初はメソッドを洗練(refine)させる典型的パターンが見られる事です。メソッド <CODE>move</CODE> はクラス <CODE>Point</CODE> のものを特化させたものです。それは最初に親クラスのメソッドを呼び出し、その後 <CODE>HistoryPoint</CODE> クラス特有のものを行います。2番目に、<CODE>DisplayHistory</CODE> メソッドはクラスにプライベートなものになっている事です。さらにはそれはサブクラスでも利用可能になっています、つまりプロテクテッドです、これは属性 <CODE>displayHistory</CODE> に保存する事で行われます。あなたはクラスを以下の文の様に試す事が出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;P<BR>P&nbsp;=&nbsp;{New&nbsp;HistoryPoint&nbsp;init(2&nbsp;0)}<BR>{P&nbsp;display}<BR>{P&nbsp;move(3&nbsp;2)}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.defaultargs"><H2><A name="section.classes.defaultargs">10.10デフォルトの引数値</A></H2><P>メソッド頭部はデフォルトの引数値を持つかもしれません。以下の例を考えて見て下さい。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(X&nbsp;Y&nbsp;d1:Z<SPAN class="keyword">&lt;=</SPAN>0&nbsp;d2:W<SPAN class="keyword">&lt;=</SPAN>0)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>メソッド <CODE>m</CODE> の呼び出しはフィールド名 <CODE>d1</CODE> と <CODE>d2</CODE> を未指定のままにしておくかもしれません。この場合、これらの引数は値0とみなされます。 </P><P><CODE>Point</CODE> の例を <CODE>Point</CODE> を他の方向で特化させて続けます。クラス <CODE>BoundedPoint</CODE> を制約された長方形領域で移動する点として定義します。領域外の点への移動の試みは無視されるでしょう。このクラスは <A href="node10.html#boundedpoint">Figure&nbsp;10.10</A> に示されます。メソッド <CODE>init</CODE> は <CODE>BoundedPoint</CODE> のインスタンス初期化時に指定されていなければデフォルトの領域を与える 2つのデフォルト引数を持っています。 </P><P></P><DIV class="figure" id="boundedpoint"><HR><P><A name="boundedpoint"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">BoundedPoint</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Point</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xbounds:&nbsp;0<SPAN class="keyword">#</SPAN>0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ybounds:&nbsp;0<SPAN class="keyword">#</SPAN>0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundConstraint:&nbsp;BoundConstraint<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y&nbsp;xbounds:XB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10&nbsp;ybounds:YB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>init(X&nbsp;Y)&nbsp;<SPAN class="comment">%&nbsp;親クラスの呼び出し<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xbounds&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;XB<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ybounds&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;YB<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;BoundConstraint(X&nbsp;Y&nbsp;$)}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>move(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">BoundConstraint</SPAN>(X&nbsp;Y&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>xbounds<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">=&lt;</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>xbounds<SPAN class="keyword">.</SPAN>2&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>ybounds<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;<SPAN class="keyword">=&lt;</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>ybounds<SPAN class="keyword">.</SPAN>2&nbsp;)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>display<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;DisplayBounds}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">DisplayBounds</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X0<SPAN class="keyword">#</SPAN>X1&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>xbounds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y0<SPAN class="keyword">#</SPAN>Y1&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>ybounds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;=&nbsp;<SPAN class="string">"xbounds=("</SPAN><SPAN class="keyword">#</SPAN>X0<SPAN class="keyword">#</SPAN><SPAN class="string">","</SPAN><SPAN class="keyword">#</SPAN>X1<SPAN class="keyword">#</SPAN><SPAN class="string">"),ybounds=("</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">#</SPAN>Y0<SPAN class="keyword">#</SPAN><SPAN class="string">","</SPAN><SPAN class="keyword">#</SPAN>Y1<SPAN class="keyword">#</SPAN><SPAN class="string">")"</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.10:</STRONG> クラス BoundedPoint</P><HR></DIV><P> </P><P>私達はこのセクションを多重継承問題を示す事によって私達の例を終わらせる事により締めます。私達は今 <CODE>HistoryPoint</CODE> と <CODE>BoundedPoint</CODE> の両方を bounded-history point として特化させたいと思っています。点は履歴を記録し続け、制約された領域を移動します。私達はこれを2つの前に定義したクラスを継承するクラス <CODE>BHPoint</CODE> を定義する事により行います。それらはステートフルな属性を含んだクラス <CODE>Point</CODE> を共有しているので、私達は実装共有問題に遭遇します。私達は色々この問題を考え、同じアクションを繰り返す事を避けるために <CODE>boundConstraint</CODE> と <CODE>displayHistory</CODE> に保存された2つのプロテクテッドメソッドを作成しました。どの場合でも、私達はメソッド <CODE>init</CODE>, <CODE>move</CODE>, <CODE>display</CODE> を洗練させなくてはなりません、なぜならそれらは2つの兄弟クラスで発生するからです。解法は <A href="node10.html#bhclass">Figure&nbsp;10.11</A> で示されます。私達がプロテクテッドメソッドを使っている事に注意して下さい。私達は属性 <CODE>x</CODE> と <CODE>y</CODE> の初期化の重複を避ける事を気にしません、なぜならそれは何の悪影響も持たないからです。以下の例を試してみて下さい: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;P<BR>P&nbsp;=&nbsp;{New&nbsp;BHPoint&nbsp;init(2&nbsp;0)}<BR>{P&nbsp;display}<BR>{P&nbsp;move(1&nbsp;2)}</CODE></BLOCKQUOTE><P> </P><P>これはオブジェクトシステムのほとんどをよくカバーしています。残っているのはオブジェクトの共通領域を並行スレッドで共有する事の扱いをどうするかです。 </P><P></P><DIV class="figure" id="bhclass"><HR><P><A name="bhclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">BHPoint</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;HistoryPoint&nbsp;BoundedPoint</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y&nbsp;xbounds:XB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10&nbsp;ybounds:YB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;init 繰り返し<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HistoryPoint<SPAN class="keyword">,</SPAN>init(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundedPoint<SPAN class="keyword">,</SPAN>init(X&nbsp;Y&nbsp;xbounds:XB&nbsp;ybounds:YB)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>boundConstraint&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;L(X&nbsp;Y&nbsp;$)}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HistoryPoint<SPAN class="keyword">,</SPAN>move(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundedPoint<SPAN class="keyword">,</SPAN>display<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>displayHistory}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.11:</STRONG> クラス BHPoint</P><HR></DIV><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html#chapter.stateful">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node11.html#chapter.objectscc">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label57">1. </A>実際には、クラスはいくつかの不可視な状態を持つかもしれません。現在の実装では、クラスは通常ステートフルなメソッドキャッシュを持ちます。</DIV><DIV class="footnote"><A name="label58">2. </A>これは簡易化です; Oz のオブジェクトはそのフィールドの一つで上の手続きを持つチャンクです; その他のフィールドはオブジェクトのフィールド名を持ちます</DIV><DIV class="footnote"><A name="label59">3. </A>短く定義するため</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
