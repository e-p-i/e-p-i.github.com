<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>4 Equality and the Equality Test Operator</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.basics">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.control">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.equality"><H1><A name="chapter.equality">4 Equality and the Equality Test Operator</A></H1><P>私達はこれまで同等性評価文の単純な例を見てきました。例えば </P><BLOCKQUOTE class="code"><CODE>W&nbsp;=&nbsp;tree(I&nbsp;Y&nbsp;LT&nbsp;LR)</CODE></BLOCKQUOTE><P> </P><P>これらは何が起こっているかを直観的に理解するのに十分な程に単純でした。しかし、2つの未束縛の変数が <CODE>X&nbsp;=&nbsp;Y</CODE> の様に同等性評価されたり、2つの大きなデータ構造が同等性評価されたりする時、何が起こるでしょうか。短い説明をします。私達はストア(store)を <EM>ノード(node)</EM> と呼ばれるメモリ単位(memory words)の動的に拡張可能な配列と考える事が出来ます。各ノードは論理変数を使ってラベル付けされます。変数 <CODE>X</CODE> がストアに新しく作られたノードに導入される時、<CODE>X</CODE> とラベル付けされ、値 <EM>unknown</EM> を持ちます。この時点では、いかなる実際の値も持ちません; それはコンテナとしては後で埋められるかもしれない空っぽのものです。 </P><P>ノードにラベリングする時にその値が <EM>unknown</EM> である変数は <EM>未束縛(unbound)</EM> の変数です。ノードは任意の Oz の値を格納するのに十分な柔軟性があります。次の操作 </P><BLOCKQUOTE class="code"><CODE>W&nbsp;=&nbsp;tree(1:I&nbsp;2:Y&nbsp;3:LT&nbsp;4:LR)</CODE></BLOCKQUOTE><P> </P><P>はレコード構造を <CODE>W</CODE> によって紐付けられたノードにストアします。私達は正にグラフ構造を得たという事に注目して下さい。このノードは4つのフィールドを持つレコードを含みます。フィールドはそれぞれ <CODE>I</CODE> ,<CODE>Y</CODE> ,<CODE>LT</CODE>, <CODE>LR</CODE> とラベル付けられたノードを指し示す弧(arc)を持ちます。それぞれの弧は順々にレコードの対応するフィールド名によってラベル付けされます。与えられた2つの変数 <CODE>X</CODE> と <CODE>Y</CODE> では、操作 <CODE>X&nbsp;=&nbsp;Y</CODE> はそれぞれのノードの <EM>併合(merge)</EM> を試みます。今、私達は併合操作 <CODE>X&nbsp;=&nbsp;Y</CODE> のために、<EM>漸増的告知(incremental tell)</EM>または<EM>単一化(unification)</EM>操作として知られる適切なアカウントを与えるべき立場にいます。 </P><UL><LI><P><I>X</I> と <I>Y</I> が同じノードをラベル付けするなら、操作は成功のうちに完了です。 </P></LI><LI><P><I>X</I> (あるいは <I>Y</I>) が未束縛ならば <I>X</I> (あるいは <I>Y</I>) のノードは <I>Y</I> (あるいは <I>X</I>) のノードへと併合されます。併合は、ノード <I>X</I> への全ての参照を <I>Y</I><A href="node4.html#label27"><SUP>1</SUP></A> へと置き換える事を意味します。概念的には元々の <I>X</I> のノードは破棄された事になります。 </P></LI><LI><P><I>X</I> と <I>Y</I> がそれぞれ <I>Rx</I> と <I>Ry</I> というレコードを含んでいる異なるノードをラベル付けしているなら: </P><UL><LI><P><I>Rx</I> と <I>Ry</I> は異なるラベル、引数、またはそのどちらもを持ちます: 操作は完了し、例外が発生します。 </P></LI><LI><P>そうでなければ、<I>Rx</I> と <I>Ry</I> の同じフィールド名の引数は任意の順序でペアとして併合されます。 </P></LI></UL><P> </P></LI></UL><P> </P><P>一般的に、2つのグラフがマージされると、循環を持つことがあります。しかしながらどの適正な併合操作の実装も以前にマージを試みたノードのペアを記憶しており、操作は正しく行われると考えられます。漸増的告知のより形式的な記述は <A href="bib.html#seif98">[Har98]</A> に見られます。 </P><P>変数がアクセス可能でなくなると、ガベージコレクション(garbage collection)がノードを回収します。 </P><P>ここに、正しい同等性評価操作のいくつかの例を示します: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;f(1:X&nbsp;2:b)&nbsp;=&nbsp;f(a&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;f(Z&nbsp;a)&nbsp;=&nbsp;Z<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;[X&nbsp;Y&nbsp;Z]}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>上は browser に <CODE>[a&nbsp;b&nbsp;R14=f(R14&nbsp;a)]</CODE> を表示するでしょう。<CODE>R14=f(R14&nbsp;a)</CODE> は循環グラフの外部表現です。 </P><P class="warning"><STRONG>注意:</STRONG> Z の有限表現を見るには、Browser を <EM>Minimal Graph</EM> 表示モードに切り替えなければなりません。Option メニュー、Representation フィールドを選択し、Minimal Graph をクリックします。 </P><P class="warning"><STRONG>注意:</STRONG> Browser は <A href="../browser/index.html">``The Oz Browser''</A> に記述されています。 </P><P>以下の例は整合性の無い値が同等性評価された時に何が起こるかを示しています。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>X&nbsp;=&nbsp;f(c&nbsp;a)<BR>Y&nbsp;=&nbsp;f(Z&nbsp;b)<BR>X&nbsp;=&nbsp;Y</CODE></BLOCKQUOTE><P> </P><P><CODE>X&nbsp;=&nbsp;Y</CODE> の漸増的告知は <CODE>Z</CODE> を値 <CODE>c</CODE> に束縛しようとするでしょう、しかしまた、<CODE>a</CODE> と <CODE>b</CODE> を同等性評価しようとした時にシステムにキャッチされる例外を発生させるでしょう。 </P><H2><A name="label26">4.1同等性テスト演算子(equality test operator) <CODE><SPAN class="keyword">==</SPAN></CODE></A></H2><P>基本的手続き <CODE>{Value<SPAN class="keyword">.</SPAN><SPAN class="string">'=='</SPAN>&nbsp;X&nbsp;Y&nbsp;R}</CODE> は <CODE>X</CODE> と <CODE>Y</CODE> が等しいかそうでないかのテストを試み、結果を <CODE>R</CODE> に返します。 </P><UL><LI><P>グラフが<CODE>X</CODE> から始まり <CODE>Y</CODE> も同じ構造を持っていてそれぞれ対応するペアが同一の Oz の値を持っているか同じノードであるならば、ブール値 <CODE><SPAN class="keyword">true</SPAN></CODE> が返ってきます。 </P></LI><LI><P>グラフが異なる構造かそれぞれ対応するペアが異なる値を持っているならば、ブール値 <CODE><SPAN class="keyword">false</SPAN></CODE> が返ってきます。 </P></LI><LI><P>対応するペアのノードが異なっていて、しかし少なくともその一方が未束縛である場合は、一時停止します。 </P></LI></UL><P> </P><P>もし手続きが一時停止すると、スレッド全体が一時停止するという事を覚えておいて下さい！これはあまり有用に見えません。しかしながら、後で見るように、これは複数のスレッドがお互いにやり取りをする時には非常に有用な操作になります。 </P><P>同等性テストは普通、文としてよりも関数の式(expression)として使われます。<CODE>{Value<SPAN class="keyword">.</SPAN><SPAN class="string">'=='</SPAN>&nbsp;X&nbsp;Y&nbsp;R}</CODE> は 中置の <CODE><SPAN class="keyword">==</SPAN></CODE> 演算子を使って <CODE>R&nbsp;=&nbsp;X<SPAN class="keyword">==</SPAN>Y</CODE> とも書けます。さらなる例を下に示します: </P><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;リストはただのレコードのタプルである事を見ましょう<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;L1&nbsp;L2&nbsp;L3&nbsp;Head&nbsp;Tail&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;L1&nbsp;=&nbsp;Head<SPAN class="keyword">|</SPAN>Tail<BR>&nbsp;&nbsp;&nbsp;Head&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;Tail&nbsp;=&nbsp;2<SPAN class="keyword">|</SPAN>nil<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;L2&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;L1<SPAN class="keyword">==</SPAN>L2}<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;L3&nbsp;=&nbsp;<SPAN class="string">'|'</SPAN>(1:1&nbsp;2:<SPAN class="string">'|'</SPAN>(2&nbsp;nil))<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;L1<SPAN class="keyword">==</SPAN>L3}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.basics">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.control">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label27">1. </A>これは他にもたくさんやり方があります。一つはノード <I>X</I> を <I>Y</I> を指すようにし、<I>X</I> を参照ノードにする事です。参照ノードのチェインは、どんな単一化操作が行われる前にも常に走査されます(traversed)。</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
