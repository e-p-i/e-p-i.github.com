<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>11 Objects and Concurrency</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#chapter.classes">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node12.html#chapter.lp">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.objectscc"><H1><A name="chapter.objectscc">11 Objects and Concurrency</A></H1><P>私達が見て来たように、Oz でのオブジェクトはステートフルなデータ構造です。スレッドはアクティブな計算の実体です。スレッドはポートを使ったメッセージパッシングか共通共有オブジェクトを通して互いにやり取りが出来ます。共有オブジェクトを通したコミュニケーションはオブジェクトの並行操作をシリアライズする能力を必要とします、そうすればオブジェクトの状態はその様なオペレーション後に整合性を保てます。Oz では、私達はオブジェクトシステムからオブジェクトの排他アクセスの取得の事柄を分離します。これは私達にオブジェクトの集合の粗い(coarse-grain)アトミックな操作を行う能力を与えます、それは例えば分散データベースシステムでは非常に重要な要求です。Oz での排他アクセスの基本的なメカニズムはロックを通したものです。 </P><DIV id="section.objectscc.lock"><H2><A name="section.objectscc.lock">11.1ロック(lock)</A></H2><P>ロックの目的はスレッド間で共有リソースへの排他アクセスを調停する事です。その様なメカニズムは典型的に、クリティカル領域への排他アクセスを制限する事により、より安全で頑健に出来ます。クリティカル領域への進入する際、ロックはセキュアになりスレッドはリソースへの排他アクセス権を与えられます、そして実行が領域を出る時、通常か例外発生によってかに関わらず、ロックは解放されます。同じロックを取得しようとする並行な試みは、ロックを保持している現在のスレッドがそれを解放するまでブロックされます。 </P><H3><A name="label60">11.1.1シンプルロック(simple lock)</A></H3><P>シンプルロックの場合、ロックにより保護されたクリティカルセクションの動的スコープの間の同じスレッドによるネストした同じロックの要求の試みは、ブロックされるでしょう。これを<EM>再入(reentrancy)</EM>がサポートされていないと呼びます。シンプルロックは Oz では以下の様にモデル化されます、ここで <CODE>Code</CODE> はクリティカルセクションで行われる計算をカプセル化した引数無しの手続きです。ロックは手続きとして表現されます: 同じコードに適用される時、それは <CODE>Old</CODE> が <CODE><SPAN class="keyword">unit</SPAN></CODE> に束縛されるまで待つ事によりロックを取得しようと試みます。通常終了と異常終了のどちらでもロックが解放される事に注意して下さい。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewSimpleLock</SPAN>&nbsp;?Lock}<BR>&nbsp;&nbsp;&nbsp;Cell&nbsp;=&nbsp;{NewCell&nbsp;<SPAN class="keyword">unit</SPAN>}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Lock</SPAN>&nbsp;Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Old&nbsp;New&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;Cell&nbsp;Old&nbsp;New}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Wait&nbsp;Old}&nbsp;{Code}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">finally</SPAN>&nbsp;New=<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label61">11.1.2オブジェクトの属性でのアトミックな交換</A></H3><P>オブジェクトを使ってロックを実装する他の実装が下に示されます。構造体を使っている事に注目して下さい: </P><BLOCKQUOTE class="code"><CODE>Old&nbsp;=&nbsp;lck&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;New</CODE></BLOCKQUOTE><P> </P><P>セルの Exchange 操作と似て、これはオブジェクトの属性のアトミックな交換です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">SimpleLock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;lck:<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="string">'lock'</SPAN>(Code)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Old&nbsp;New&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Old&nbsp;=&nbsp;lck&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;New<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Wait&nbsp;Old}&nbsp;{Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">finally</SPAN>&nbsp;New=&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.objectscc.reentrant"><H2><A name="section.objectscc.reentrant">11.2スレッド再入ロック(Thread-Reentrant Lock)</A></H2><P>Oz では、計算の単位はスレッドです。それゆえ、適切なロック機構はスレッドに排他アクセスの権利を与えるでしょう。上で表現された非再入のシンプルロック機構の結果は不適当です。スレッド再入ロックは同じスレッドにロック部分への再入を許します、つまり、動的に同じロックによって保護されたネストしたクリティカル領域に入れるという事です。その様はロックは一度に高々1スレッドに取得され得ます。同じロックを取得しようとする並行スレッドはキューされます。ロックが解放された時、ラインetcに最初に並んでいるスレッドに権利が与えられます。スレッド再入ロックは Oz では以下の様にモデル化され得ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ReentrantLock</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;SimpleLock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;Current:<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="string">'lock'</SPAN>(Code)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThisThread&nbsp;=&nbsp;{Thread<SPAN class="keyword">.</SPAN>this}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;ThisThread&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>Current&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Code1</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;ThisThread<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">finally</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleLock<SPAN class="keyword">,</SPAN>&nbsp;<SPAN class="string">'lock'</SPAN>(Code1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>スレッド再入ロックは Oz で構文と実装のサポートが与えられています。それらはチャンクのサブ型として実装されています。Oz は保護されたクリティカル領域のために以下の構文を提供しています: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">lock</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><I>E</I> はロックに評価される式です。この構造体は <I>S</I> が実行されるまでブロックします。<I>E</I> がロックされていなければ、型エラーが発生します。 </P><UL><LI><P><CODE>{NewLock&nbsp;L}</CODE> は新しいロック <CODE>L</CODE> を生成します。 </P></LI><LI><P><CODE>{IsLock&nbsp;E</CODE>} は <CODE>E</CODE> がロックされている時に true を返します。 </P></LI></UL><P> </P><H3><A name="label62">11.2.1配列(array)</A></H3><P>Oz はチャンクのサブ型として配列を持っています。配列の操作はモジュール <CODE>Array</CODE> で定義されています。 </P><UL><LI><P><CODE>{NewArray&nbsp;<SPAN class="keyword">+</SPAN>L&nbsp;<SPAN class="keyword">+</SPAN>H&nbsp;<SPAN class="keyword">+</SPAN>I&nbsp;?A}</CODE> は配列 <CODE>A</CODE> を作ります、ここで <CODE>L</CODE> はインデックスの下限で、<CODE>H</CODE> はインデックスの上限で、<CODE>I</CODE> は配列要素の初期値です。 </P></LI><LI><P><CODE>{Array<SPAN class="keyword">.</SPAN>low&nbsp;<SPAN class="keyword">+</SPAN>A&nbsp;?L}</CODE> はインデックスの下限を返します。 </P></LI><LI><P><CODE>{Array<SPAN class="keyword">.</SPAN>high&nbsp;<SPAN class="keyword">+</SPAN>A&nbsp;?L}</CODE> はインデックスは上限を返します。 </P></LI><LI><P><CODE>R<SPAN class="keyword">:=</SPAN>A<SPAN class="keyword">.</SPAN>I</CODE> は <CODE>R</CODE> の <CODE>A[I]</CODE> を返します。 </P></LI><LI><P><CODE>A<SPAN class="keyword">.</SPAN>I<SPAN class="keyword">:=</SPAN>X</CODE> は <CODE>X</CODE> にエントリ <CODE>A[I]</CODE> を割り当てます。 </P></LI></UL><P> </P><P>ロックの使用の簡単な図示として <A href="node11.html#usinglock">Figure&nbsp;11.1</A> のプログラムを考えましょう。手続き <CODE>Switch</CODE> は配列の負の要素を正に変更し、0要素をアトム <CODE>zero</CODE> に変更します！手続き <CODE>Zero</CODE> は全ての要素を0にリセットします。 </P><P></P><DIV class="figure" id="usinglock"><HR><P><A name="usinglock"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;A&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>A&nbsp;=&nbsp;{NewArray&nbsp;1&nbsp;100&nbsp;<SPAN class="keyword">~</SPAN>5}<BR>L&nbsp;=&nbsp;{NewLock}<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Switch</SPAN>&nbsp;A}<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;{Array<SPAN class="keyword">.</SPAN>low&nbsp;A}&nbsp;{Array<SPAN class="keyword">.</SPAN>high&nbsp;A}&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">&lt;</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">~</SPAN>X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;0&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;zero&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Delay&nbsp;100}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Zero</SPAN>&nbsp;A}<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;{Array<SPAN class="keyword">.</SPAN>low&nbsp;A}&nbsp;{Array<SPAN class="keyword">.</SPAN>high&nbsp;A}&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;0&nbsp;{Delay&nbsp;100}&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.1:</STRONG> ロックの使用</P><HR></DIV><P> </P><P>以下のプログラムを試してみて下さい。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Zero&nbsp;A}&nbsp;X&nbsp;=&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Switch&nbsp;A}&nbsp;Y&nbsp;=&nbsp;X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Wait&nbsp;Y}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;10&nbsp;1&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Browse&nbsp;A<SPAN class="keyword">.</SPAN>I}&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>配列の要素は <CODE>0</CODE> と <CODE>zero</CODE> が混ざったものになるでしょう。 </P><P>私達は手続き <CODE>Zero</CODE> と <CODE>Switch</CODE> にアトミックでしかし任意の順番で振る舞って欲しいと想定しましょう。そのためには私達は以下の例での様にロックを使用できます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Delay&nbsp;100}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;L&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Zero&nbsp;A}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;L&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Switch&nbsp;A}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;X&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Wait&nbsp;Y}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;10&nbsp;1&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Browse&nbsp;&nbsp;A<SPAN class="keyword">.</SPAN>I}&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>上で最初と2番目のスレッド間で delay 文に変更する事によって、私達は配列の全ての要素が値 <CODE>zero</CODE> か <CODE>0</CODE> のどちらかを得る事を見る事になります。私達は混ざった値を持っていません。 </P><P class="warning"><STRONG>注意:</STRONG>*** 複数のロックを使った複数のオブジェクトにおいてのアトミックなトランザクションの例を書いて下さい。 </P></DIV><DIV id="section.objectscc.lockobject"><H2><A name="section.objectscc.lockobject">11.3オブジェクトのロック</A></H2><P>オブジェクトでの相互排他を保証するためには、前の節で記述されたロックを使うかもしれません。代替として、クラスの中で、オブジェクトが生成された時に存在するデフォルトのロックによってインスタンスオブジェクトをロック出来ます。暗黙のロックをともなったクラスは以下の様に宣言されます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;</CODE><I>C</I><CODE>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">....</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;<SPAN class="keyword">....</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>これはオブジェクトのメソッドの一つが呼び出された時に、自動的にオブジェクトをロックします。代わりに構造体を使わなければいけません: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">lock</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><I>S</I> が実行される時には内部のどのメソッドも排他アクセスである事を保証します。私達のロックが再入可能である事を思い出して下さい。これは次の事を暗に言っています: </P><UL><LI><P>もし私達が、私達が構築し、各メソッド本体部を <CODE><SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> で閉じたオブジェクトを全て取り、 </P></LI><LI><P>私達のプログラムを1スレッドでしか実行しないのであれば、 </P></LI><LI><P>プログラムは以前の様に正確に振る舞うでしょう </P></LI></UL><P> </P><P>もちろん、複数のオブジェクトのメソッドを複数のスレッドで呼び出すなら、そこに循環的依存があれば私達はデッドロックに出会うでしょう。自明でない並行プログラムを書く事はスレッド間の依存パターンの注意深い理解を要します。その様なプログラムにおけるデッドロックはロックが使われているかどうかに関わらず発生します。循環的コミュニケーションパターンを持つ事はデッドロックの発生のために有害です。 </P><P><A href="node10.html#counterclass">Figure&nbsp;10.3</A> のプログラムは以下の様に洗練させる事で並行環境でも働く事が出来るように洗練させる事が出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">CCounter</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Counter</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">inc</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;Counter<SPAN class="keyword">,</SPAN>inc(Value)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;Counter<SPAN class="keyword">,</SPAN>init(Value)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>さあ、スレッドがオブジェクトでただアトミックなトランザクションを行うだけでなく、オブジェクトを通して同期を行うような、数々の興味深い例について学びましょう。 </P></DIV><DIV id="section.objectscc.fifo"><H2><A name="section.objectscc.fifo">11.4並行FIFOチャネル</A></H2><P>最初の例は任意の数のスレッド間で共有される並行チャネルを示します。どの生産者スレッドも情報をチャネルに非同期にputする事が出来ます。消費者スレッドはチャネルに情報が表れるまで待たなければいけません。スレッドの待機は公平に提供されます。<A href="node11.html#asyncchannel">Figure&nbsp;11.2</A> は現実化としてありえるうちの一つを示しますこのプログラムは望まれる同期を達成するために論理変数の使用に頼っています。メソッド <CODE>put<SPAN class="keyword">/</SPAN>1</CODE> は要素をチャネルに挿入します。メソッド <CODE>get<SPAN class="keyword">/</SPAN>1</CODE> を実行するスレッドはチャネルに要素が挿入されるまで待ちます。複数の消費者スレッドはチャネルに自らの場所を予約し、それにより公平さを達成します。<CODE>{Wait&nbsp;I}</CODE> が排他領域の外側で行われる事に注目して下さい。待機が <CODE><SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> の内側で行われると、プログラムはデッドロックするでしょう。それで、ルールの概要は次の様になります: </P><UL><LI><P>起床動作(waking-up action)が同じロックを必要とする時は、排他領域の内側で待機してはいけない。 </P></LI></UL><P> </P><P></P><DIV class="figure" id="asyncchannel"><HR><P><A name="asyncchannel"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Channel</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;f&nbsp;r<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;f&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X&nbsp;r&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">put</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>r=I<SPAN class="keyword">|</SPAN>X&nbsp;r<SPAN class="keyword">:=</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(?I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>f=I<SPAN class="keyword">|</SPAN>X&nbsp;f<SPAN class="keyword">:=</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;{Wait&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.2:</STRONG> 非同期チャネルクラス</P><HR></DIV><P></P></DIV><DIV id="section.objectscc.monitor"><H2><A name="section.objectscc.monitor">11.5モニタ(monitor)</A></H2><P>次の例は<EM>モニタ(monitor)</EM>を書く伝統的な方法を示します。私達はイベントの記法と <CODE>Channel</CODE> を特化したモニタ操作 <CODE>notify(Event)</CODE> と <CODE>wait(Event)</CODE> を定義するクラスの定義を開始します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Event</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Channel</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">wait</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;get(_)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">notify</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;put(<SPAN class="keyword">unit</SPAN>)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>私達はここで伝統的なモニタスタイルでのunitバッファの例を示しています。unitバッファは消費者に来る時のチャネルにとても似た方法で振る舞います。各消費者はバッファが一杯になるまで待機します。生産者の場合は一つのみがアイテムを空のバッファに挿入する事が許されています。他の生産者はアイテムが消費されるまで一時停止しなければなりません。<A href="node11.html#ubmonitor">Figure&nbsp;11.3</A> のプログラムは単一バッファモニタを示しています。ここで私達は生産者と消費者のためにシグナルのメカニズムをプログラムしなければなりません。<CODE>put<SPAN class="keyword">/</SPAN>1</CODE> と <CODE>get<SPAN class="keyword">/</SPAN>1</CODE> メソッドでのパターンを観察して下さい。ほとんどの実行は排他領域で行われます。待機が必要ならそれは排他領域の外側で行われます。これは <CODE>yes</CODE> への束縛を得る付属の変数 <CODE>X</CODE> を使って行われます。<CODE>get<SPAN class="keyword">/</SPAN>1</CODE> メソッドは一つの生産者に <CODE>empty</CODE> フラグをセットする時に知らせ、一つの生産者(もしあれば)に知らせます。これはアトミックなステップで行われます。<CODE>put<SPAN class="keyword">/</SPAN>1</CODE> メソッドは相互アクションを行います。 </P><P></P><DIV class="figure" id="ubmonitor"><HR><P><A name="ubmonitor"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">UnitBufferM</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;item&nbsp;empty&nbsp;psignal&nbsp;csignal<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;psignal&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csignal&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">put</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>empty&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;I<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;yes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>csignal&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;X&nbsp;=&nbsp;no&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;no&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>psignal&nbsp;wait}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;put(I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{Not&nbsp;<SPAN class="keyword">@</SPAN>empty}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>item<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>psignal&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;yes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;X&nbsp;=&nbsp;no&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;no&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>csignal&nbsp;wait}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;get(I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.3:</STRONG> unitバッファモニタ</P><HR></DIV><P> </P><P>上の例を以下のコードを走らせて試してみて下さい: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;UB&nbsp;=&nbsp;{New&nbsp;UnitBufferM&nbsp;init}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{For&nbsp;1&nbsp;15&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{UB&nbsp;put(I)}&nbsp;{Delay&nbsp;500}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;{For&nbsp;1&nbsp;15&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{UB&nbsp;get({Browse}}{Delay&nbsp;500}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label63">11.5.1Oz スタイルの有界バッファ(bounded buffer)</A></H3><P>Oz では、上で示されたモニタスタイルのプログラムを書くのはとても稀な事です。通常、それは不格好です。伝統的ではない <CODE>UnitBuffer</CODE> クラスを書くためのより簡単な方法があります。これはオブジェクトと論理変数の組み合わせによるもので、<A href="node11.html#unitbuffer">Figure&nbsp;11.4</A> に簡単な定義を示しています。直接的なロックは不要です。 </P><P></P><DIV class="figure" id="unitbuffer"><HR><P><A name="unitbuffer"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">UnitBuffer</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;prodq&nbsp;buffer<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Channel&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prodq&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">put</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;wait}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>buffer&nbsp;put(I)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(?I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>buffer&nbsp;get(I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.4:</STRONG> unitバッファ</P><HR></DIV><P> </P><P>上のプログラムのシンプルな一般化は任意のサイズの有界バッファクラスに導きます。これは下で示されます。put と get メソッドは前と同じです。初期化メソッドだけが変更されています。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">BoundedBuffer</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;UnitBuffer</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;prodq&nbsp;buffer<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(N)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Channel&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prodq&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;N&nbsp;1&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;_}&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;notify}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.objectscc.active"><H2><A name="section.objectscc.active">11.6動的オブジェクト(active object)</A></H2><P>動的オブジェクトはクラス定義によって記述される振る舞いを持つスレッドです。動的オブジェクトとのコミュニケーションは非同期メッセージパッシングを通して行われます。動的オブジェクトは受け取ったメッセージに関連するクラスの対応するメソッドを実行する事によって反応します。動的オブジェクトは一度に一つのメソッドを実行します。それゆえ動的オブジェクトによって実行されるメソッドのためにロックは不要です。動的オブジェクトへのインターフェースは Oz のポートを通したものです。動的オブジェクトのクライアントは関連するポートにメッセージを送る事により、オブジェクトにメッセージを送ります。私達は一般的にこの抽象をどの様に生成するかを示します。動的オブジェクトはネットワークを通してクライアントからメッセージを受け取るサーバに似ているので、私達はこの抽象をサーバ抽象と呼びます。クラス Class からサーバ <CODE>S</CODE> を生成するために次を実行します: </P><BLOCKQUOTE class="code"><CODE>S&nbsp;=&nbsp;{NewServer&nbsp;Class&nbsp;init}</CODE></BLOCKQUOTE><P> </P><P>ここで <CODE>init</CODE> は初期オブジェクト構築メソッドです。基本的な概念を得るために、最初に <CODE>NewServer</CODE> 関数の簡単な形式を示します。以下の関数: </P><UL><LI><P>ポート生成 <CODE>Port</CODE>, </P></LI><LI><P>オブジェクト生成 <CODE>Object</CODE>, そして最後に </P></LI><LI><P>対応するクラスのメソッドを適用する事による、ポートにメッセージを送るサーバのスレッド生成。 </P></LI></UL><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewServer</SPAN>&nbsp;Class&nbsp;Init}<BR>&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;ポートのストリーム<BR></SPAN>&nbsp;&nbsp;&nbsp;Port&nbsp;=&nbsp;{NewPort&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;Object&nbsp;=&nbsp;{New&nbsp;Class&nbsp;Init}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{ForAll&nbsp;S&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}&nbsp;{Object&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Port<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>私達は <CODE>Class</CODE> の中のメソッドにアクセス可能なプロテクテッドメソッド <CODE>Close</CODE> を作ることによってスレッド終了の能力を追加したいと思います。これは私達を上の関数の以下の拡張に導きます。私達は受け取りループの外側にジャンプするために例外制御機構を使います。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Server</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;close:Close<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">Close</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;closeException&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewServer</SPAN>&nbsp;Class&nbsp;Init}<BR>&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;ポートのストリーム<BR></SPAN>&nbsp;&nbsp;&nbsp;Port&nbsp;=&nbsp;{NewPort&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;Object&nbsp;=&nbsp;{New&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Server&nbsp;Class</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;Init}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;{ForAll&nbsp;S&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}&nbsp;{Object&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;closeException&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Port<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#chapter.classes">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node12.html#chapter.lp">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
