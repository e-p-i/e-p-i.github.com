<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>Tutorial of Oz</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><P class="margin"><A href="../index.html">Top</A><BR><A href="http://www.mozart-oz.org/download/view.cgi?action=print&amp;class=tutorial&amp;name=Oz">Print</A></P><H1 align="center" class="title">Tutorial of Oz</H1><H2 align="center" class="authors"><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A></H2><P></P><DIV align="center"><IMG alt="" src="tutorial.gif"></DIV><P></P><BLOCKQUOTE><P>このチュートリアルは、プログラミング言語 Oz とMozart プログラミングシステムへの導入のためのものです。Oz は、先進、並行(concurrent)、ネットワーク、ソフトリアルタイム(soft real-time)、そしてリアクティブアプリケーション(reactive application)のためにデザインされたマルチパラダイム言語(multi-paradigm language)です。Oz はオブジェクト指向プログラミング(object-oriented programming)の顕著な特徴である、状態(state)、抽象データ型(abstract data type)、オブジェクト(object)、クラス(class)、そして継承(inheritance)を提供します。また関数型プログラミング(functional programming)の顕著な特徴である、合成構文(compositional syntax)、第一級の手続き/関数(first-class procedure/function)、そしてレキシカルスコープ(lexical scoping)を提供します。また論理プログラミング(logic programming)と制約プログラミング(constraint programming)の顕著な特徴である、論理変数(logic variable)、制約(constraint)、選言的構築(disjunction constructs)、そしてプログラム可能な探索(search)機構を提供します。またユーザーに動的に大量のシーケンシャルスレッドを生成する事を許します。このスレッドは、スレッドが操作を実行するのを全ての被演算子(operand)が解決(well-defined)された値になるまで待機するという意味で、データフロースレッドです。 </P><P>チュートリアルは Oz のコンセプトの大部分をインフォーマルなやり方でカバーします。理論的背景なしにすぐにプログラムを書き始められるようになりたいプログラマーにとって、最初に読むのに適しています。文書はインフォーマルに提供され、他の Oz の文書を補完するものになっています。 </P><P>Mozart プログラミングシステムは DFKI (the German Research Center for Artificial Intelligence)、 SICS (the Swedish Institute of Computer Science)、 the University of the Saarland、 UCL (the Universit� catholique de Louvain)、およびその他の研究者によって開発されました。 </P></BLOCKQUOTE><HR><UL class="toc"><LI><A href="node1.html#chapter.introduction">1 Introduction</A><UL class="toc"><LI><A href="node1.html#label1">1.1Oz の特徴のまとめ</A></LI><LI><A href="node1.html#label2">1.2核言語(kernel language)</A></LI><LI><A href="node1.html#label3">1.3クラス(class)</A></LI><LI><A href="node1.html#label4">1.4オブジェクト(object)</A></LI><LI><A href="node1.html#label5">1.5再入ロック(reentrant lock)</A></LI><LI><A href="node1.html#label6">1.6ポート(port)</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node2.html#chapter.opi">2 The Interactive Development Environment</A><UL class="toc"><LI><A href="node2.html#label7">2.1OPI を始める</A></LI><LI><A href="node2.html#label8">2.2 Hello World</A></LI><LI><A href="node2.html#label9">2.3プログラマへの良いニュース</A><UL class="toc"><LI><A href="node2.html#label10">2.3.1コード編集</A></LI><LI><A href="node2.html#label11">2.3.2キーバインド</A></LI><LI><A href="node2.html#label12">2.3.3コンパイルエラー</A></LI><LI><A href="node2.html#label13">2.3.4グラフィカルな開発ツール</A></LI></UL></LI></UL></LI></UL><UL class="toc"><LI><A href="node3.html#chapter.basics">3 Basics</A><UL class="toc"><LI><A href="node3.html#label14">3.1Oz の主要な型(type)</A></LI><LI><A href="node3.html#label15">3.2情報を追加する</A></LI><LI><A href="node3.html#label16">3.3構造同等性(structual equality)とデータ型(data type)</A></LI><LI><A href="node3.html#label17">3.4数値(number)</A></LI><LI><A href="node3.html#label18">3.5リテラル(literal)</A></LI><LI><A href="node3.html#label19">3.6レコード(record)とタプル(tuple 組)</A></LI><LI><A href="node3.html#label20">3.7レコードの操作</A></LI><LI><A href="node3.html#label21">3.8リスト(list)</A></LI><LI><A href="node3.html#label22">3.9仮想文字列(virtual string)</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node4.html#chapter.equality">4 Equality and the Equality Test Operator</A><UL class="toc"><LI><A href="node4.html#label26">4.1同等性テスト演算子(equality test operator) <CODE><SPAN class="keyword">==</SPAN></CODE></A></LI></UL></LI></UL><UL class="toc"><LI><A href="node5.html#chapter.control">5 Basic Control Structures</A><UL class="toc"><LI><A href="node5.html#label28">5.1 skip</A></LI><LI><A href="node5.html#control.if">5.2If 文</A><UL class="toc"><LI><A href="node5.html#label29">5.2.1意味論(semantics)</A></LI><LI><A href="node5.html#label30">5.2.2略語(abbreviation)</A></LI></UL></LI><LI><A href="node5.html#control.procedure">5.3手続き抽象(procedural abstraction)</A><UL class="toc"><LI><A href="node5.html#label31">5.3.1手続き定義(procedure definition)</A></LI><LI><A href="node5.html#label32">5.3.2意味論(semantics)</A></LI></UL></LI><LI><A href="node5.html#control.lexical">5.4レキシカルスコープ(lexical scoping)</A></LI><LI><A href="node5.html#control.anonymous">5.5匿名手続き(anonymous procedure)と変数初期化(variable initialization)</A></LI><LI><A href="node5.html#control.pattern">5.6パターンマッチ(pattern matching)</A><UL class="toc"><LI><A href="node5.html#label33">5.6.1case 文</A></LI><LI><A href="node5.html#label34">5.6.2意味論(semantics)</A></LI></UL></LI><LI><A href="node5.html#control.nesting">5.7ネスト(nesting)</A><UL class="toc"><LI><A href="node5.html#label37">5.7.1関数のネスト(functional nesting)</A></LI></UL></LI><LI><A href="node5.html#control.procasvals">5.8値としての手続き</A></LI><LI><A href="node5.html#control.controlabs">5.9制御抽象(control abstraction)</A></LI><LI><A href="node5.html#control.exception">5.10例外制御(exception handling)</A></LI><LI><A href="node5.html#control.sysexcept">5.11システム例外(system exception)</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node6.html#chapter.functional">6 Functions</A><UL class="toc"><LI><A href="node6.html#label41">6.1関数記法(functional notation)</A><UL class="toc"><LI><A href="node6.html#label42">6.1.1 <CODE><SPAN class="keyword">andthen</SPAN></CODE> と <CODE><SPAN class="keyword">orelse</SPAN></CODE></A></LI><LI><A href="node6.html#label43">6.1.2関数にするか関数にしないか？</A></LI></UL></LI></UL></LI></UL><UL class="toc"><LI><A href="node7.html#chapter.modules">7 Modules and Interfaces</A></LI></UL><UL class="toc"><LI><A href="node8.html#chapter.concurrency">8 Concurrency</A><UL class="toc"><LI><A href="node8.html#section.concurrency.time">8.1 Time</A><UL class="toc"><LI><A href="node8.html#label48">8.1.1スタンドアロンなアプリケーションを作る</A></LI></UL></LI><LI><A href="node8.html#section.concurrency.stream">8.2 Stream Communication</A></LI><LI><A href="node8.html#section.concurrency.priority">8.3スレッド優先度(thread priority)とリアルタイム</A></LI><LI><A href="node8.html#section.concurrency.demanddriven">8.4要求駆動(demand-driven)実行</A><UL class="toc"><LI><A href="node8.html#label49">8.4.1フューチャ(future) </A></LI></UL></LI><LI><A href="node8.html#section.concurrency.termination">8.5スレッド終了の検知</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node9.html#chapter.stateful">9 Stateful Data Types</A><UL class="toc"><LI><A href="node9.html#section.stateful.port">9.1ポート(port)</A></LI><LI><A href="node9.html#section.stateful.clientserver">9.2クライアント-サーバ コミュニケーション</A></LI><LI><A href="node9.html#section.stateful.chunk">9.3チャンク(chunk)</A></LI><LI><A href="node9.html#section.stateful.cell">9.4セル(cell)</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node10.html#chapter.classes">10 Classes and Objects</A><UL class="toc"><LI><A href="node10.html#section.classes.classprinciples">10.1第一原理からのクラス</A></LI><LI><A href="node10.html#section.classes.objectprinciples">10.2第一原理からのオブジェクト</A></LI><LI><A href="node10.html#section.classes.forreal">10.3実際のオブジェクトとクラス</A><UL class="toc"><LI><A href="node10.html#label53">10.3.1静的メソッド(static method)の呼び出し</A></LI><LI><A href="node10.html#label54">10.3.2モジュールとしてのクラス</A></LI></UL></LI><LI><A href="node10.html#section.classes.inheritance">10.4継承(inheritance)</A><UL class="toc"><LI><A href="node10.html#label55">10.4.1多重継承(multiple inheritance)か否か</A></LI></UL></LI><LI><A href="node10.html#section.classes.features">10.5フィールド名(feature)</A><UL class="toc"><LI><A href="node10.html#label56">10.5.1フィールドの初期化</A></LI></UL></LI><LI><A href="node10.html#section.classes.parametrized">10.6パラメータ化されたクラス</A></LI><LI><A href="node10.html#section.classes.self">10.7自己適用(self application)</A></LI><LI><A href="node10.html#section.classes.attributes">10.8属性(attribute)</A></LI><LI><A href="node10.html#section.classes.private">10.9プライベート(private)とプロテクテッド(protected)なメソッド</A></LI><LI><A href="node10.html#section.classes.defaultargs">10.10デフォルトの引数値</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node11.html#chapter.objectscc">11 Objects and Concurrency</A><UL class="toc"><LI><A href="node11.html#section.objectscc.lock">11.1ロック(lock)</A><UL class="toc"><LI><A href="node11.html#label60">11.1.1シンプルロック(simple lock)</A></LI><LI><A href="node11.html#label61">11.1.2オブジェクトの属性でのアトミックな交換</A></LI></UL></LI><LI><A href="node11.html#section.objectscc.reentrant">11.2スレッド再入ロック(Thread-Reentrant Lock)</A><UL class="toc"><LI><A href="node11.html#label62">11.2.1配列(array)</A></LI></UL></LI><LI><A href="node11.html#section.objectscc.lockobject">11.3オブジェクトのロック</A></LI><LI><A href="node11.html#section.objectscc.fifo">11.4並行FIFOチャネル</A></LI><LI><A href="node11.html#section.objectscc.monitor">11.5モニタ(monitor)</A><UL class="toc"><LI><A href="node11.html#label63">11.5.1Oz スタイルの有界バッファ(bounded buffer)</A></LI></UL></LI><LI><A href="node11.html#section.objectscc.active">11.6動的オブジェクト(active object)</A></LI></UL></LI></UL><UL class="toc"><LI><A href="node12.html#chapter.lp">12 Logic Programming</A><UL class="toc"><LI><A href="node12.html#label64">12.1制約ストア(constraint store)</A></LI><LI><A href="node12.html#label65">12.2計算空間(computation space)</A></LI><LI><A href="node12.html#label66">12.3制約の含意(entailment)と非含意(disentailment)</A><UL class="toc"><LI><A href="node12.html#label67">12.3.1例</A></LI></UL></LI><LI><A href="node12.html#label68">12.4選言(disjunction)</A><UL class="toc"><LI><A href="node12.html#label69">12.4.1 or 文</A></LI><LI><A href="node12.html#label70">12.4.2短縮記法</A></LI><LI><A href="node12.html#label71">12.4.3Prolog との比較</A></LI></UL></LI><LI><A href="node12.html#label72">12.5決定性駆動実行(Determinacy Driven Execution)</A></LI><LI><A href="node12.html#label73">12.6条件(conditional)</A><UL class="toc"><LI><A href="node12.html#label74">12.6.1論理条件(logical condition)</A></LI><LI><A href="node12.html#label75">12.6.2Prolog との比較</A></LI><LI><A href="node12.html#label76">12.6.3並列(parallel)の条件</A></LI></UL></LI><LI><A href="node12.html#label77">12.7非決定性(nondeterministic)プログラムと探索(search)</A><UL class="toc"><LI><A href="node12.html#label78">12.7.1 <CODE><SPAN class="keyword">dis</SPAN></CODE> 構造</A></LI><LI><A href="node12.html#label79">12.7.2定義節文法(Define Clause Grammer)</A></LI><LI><A href="node12.html#label80">12.7.3いくつかの探索手続き</A></LI><LI><A href="node12.html#label81">12.7.4dis 構造</A></LI><LI><A href="node12.html#label82">12.7.5否定(negation)</A></LI><LI><A href="node12.html#label83">12.7.6動的述語(dynamic predicate)</A></LI><LI><A href="node12.html#label84">12.7.7基本的な space ライブラリ</A></LI><LI><A href="node12.html#label85">12.7.8例: シンプルなエキスパートシステム(expert system)</A></LI></UL></LI></UL></LI></UL><UL class="toc"><LI><A href="bib.html#label86">Bibliography</A></LI></UL><HR><H1><A name="label87">Index</A></H1><CENTER><TABLE border="1" cellpadding="2"><TR><TD><A href="#_M">M</A></TD><TD><A href="#_N">N</A></TD><TD><A href="#_T">T</A></TD><TD><A href="#_U">U</A></TD></TR></TABLE></CENTER><H3 class="margin"><A name="_M">M</A></H3><DL><DT>merge</DT><DD><DL><DT><A>merging nodes</A>: see <A href="index.html#idx.unification">unification</A> (<A href="node4.html#label25">4 Equality and the Equality Test Operator</A>)</DT></DL></DD></DL><H3 class="margin"><A name="_N">N</A></H3><DL><DT><A>nesting</A>: <A href="node5.html#label35">5.7 Nesting</A></DT></DL><DL><DT>nesting</DT><DD><DL><DT><A>marker</A>: <A href="node5.html#label36">5.7 Nesting</A></DT></DL></DD></DL><H3 class="margin"><A name="_T">T</A></H3><DL><DT>tell</DT><DD><DL><DT><A>incremental</A>: see <A href="index.html#idx.unification">unification</A> (<A href="node4.html#label24">4 Equality and the Equality Test Operator</A>)</DT></DL></DD></DL><H3 class="margin"><A name="_U">U</A></H3><DL><DT><A name="idx.unification">unification</A>: <A href="node4.html#label23">4 Equality and the Equality Test Operator</A></DT></DL><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
