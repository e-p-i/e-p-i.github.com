<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>8 Concurrency</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node7.html#chapter.modules">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node9.html#chapter.stateful">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.concurrency"><H1><A name="chapter.concurrency">8 Concurrency</A></H1><P>これまで、私達は1スレッドでの実行しか見てきませんでした。今こそ並行性を導入する時です。Oz では制御の新しい並行スレッドは次によって生み出されます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>この文の実行により、現在のスレッドと並行して走るスレッドが分岐(fork)します。現在のスレッドは次の文によって再開します。それぞれの終了していないかつブロックされていないスレッドは、プロセッサの時分割で最終的に割り当てられます。これはスレッドは公平に実行される事を意味します。 </P><P>しかしながら、3つの優先度レベルがあります: <EM>high</EM>, <EM>medium</EM>, そして <EM>low</EM> です。これらは時分割でどの程度スレッドが割り当てられるかを決定します。Oz では、高優先度のスレッドは低優先度のスレッドを飢え(starve)させません。優先度はスレッドが得る事の出来るプロセッサの資源がどの程度の割合の大きさなのかを指定するだけです。 </P><P>それぞれのスレッドはユニークな名前を持っています。現在のスレッドの名前を得るには、手続き <CODE>Thread<SPAN class="keyword">.</SPAN>this<SPAN class="keyword">/</SPAN>1</CODE> を呼び出します。名前を使ってスレッドへの参照を持つ事は、スレッドにおいてスレッドの終了やスレッドでの例外発生の操作を行う事を可能にします。スレッド操作は基本モジュール <CODE>Thread</CODE> で定義されています。 </P><P>私達がスレッドについて何が出来るかを見てみましょう。最初に、各スレッドはデータの依存によりブロックされるデータフロースレッドである事を思い出して下さい。以下のプログラムについて考えましょう: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;X0&nbsp;X1&nbsp;X2&nbsp;X3&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;Y0&nbsp;Y1&nbsp;Y2&nbsp;Y3&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;[Y0&nbsp;Y1&nbsp;Y2&nbsp;Y3]}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y0&nbsp;=&nbsp;X0<SPAN class="keyword">+</SPAN>1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y1&nbsp;=&nbsp;X1<SPAN class="keyword">+</SPAN>Y0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y2&nbsp;=&nbsp;X2<SPAN class="keyword">+</SPAN>Y1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y3&nbsp;=&nbsp;X3<SPAN class="keyword">+</SPAN>Y2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;completed}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>{Browse&nbsp;[X0&nbsp;X1&nbsp;X2&nbsp;X3]}</CODE></BLOCKQUOTE><P> </P><P>このプログラムを入力して Browser で見ると、変数が未束縛な事が見えるでしょう。今、以下の文を一度に一つずつ入力して何が起こるかを観察しましょう: </P><BLOCKQUOTE class="code"><CODE>X0&nbsp;=&nbsp;0<BR>X1&nbsp;=&nbsp;1<BR>X2&nbsp;=&nbsp;2<BR>X3&nbsp;=&nbsp;3</CODE></BLOCKQUOTE><P> </P><P>あなたはどの様にスレッドが再開し再び一時停止するかを見るでしょう。最初に <CODE>X0</CODE> が束縛されるとスレッドは <CODE>Y0&nbsp;=&nbsp;X0<SPAN class="keyword">+</SPAN>1</CODE> を実行し、次の <CODE>Y1&nbsp;= X1<SPAN class="keyword">+</SPAN>Y0<SPAN class="keyword"></SPAN></CODE> の実行中に <CODE>X1</CODE> の値を必要とするので再び一時停止します、等々。 </P><P></P><DIV class="figure" id="concurrentmap"><HR><P><A name="concurrentmap"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Map</SPAN>&nbsp;Xs&nbsp;F}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{F&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">|</SPAN>{Map&nbsp;Xr&nbsp;F}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.1:</STRONG> 並行 Map 関数</P><HR></DIV><P> </P><P><A href="node8.html#concurrentmap">Figure&nbsp;8.1</A> で示されるプログラムは並行 <CODE>Map</CODE> 関数を定義しています。<CODE><SPAN class="keyword">thread</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> がここでは一つの式として使われている事に注視して下さい。このプログラムの振る舞いについて論じましょう。私達が以下の文に入った時: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR>F&nbsp;X&nbsp;Y&nbsp;Z<BR>{Browse&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Map&nbsp;X&nbsp;F}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> </P><P>スレッド実行 <CODE>Map</CODE> が作られます。それは <CODE>X</CODE> が未束縛なためにcase文で即時に一時停止するでしょう。その後、私達は以下の文に入ります: </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>Y<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">F</SPAN>&nbsp;X}&nbsp;X<SPAN class="keyword">*</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>メインのスレッドはリストの最初の2つの引数 <CODE><SPAN class="keyword">thread</SPAN>&nbsp;{F&nbsp;1}&nbsp;<SPAN class="keyword">end</SPAN></CODE> と <CODE><SPAN class="keyword">thread</SPAN>&nbsp;{F&nbsp;2}&nbsp;<SPAN class="keyword">end</SPAN></CODE> のために2つのスレッドを作るリストを走査し、リストの尾部 <CODE>Y</CODE> で再び一時停止するでしょう。最終的に、 </P><BLOCKQUOTE class="code"><CODE>Y&nbsp;=&nbsp;3<SPAN class="keyword">|</SPAN>Z<BR>Z&nbsp;=&nbsp;nil</CODE></BLOCKQUOTE><P> </P><P>はメインのスレッドと新しく生成されたスレッド <CODE><SPAN class="keyword">thread</SPAN>&nbsp;{F&nbsp;3}&nbsp;<SPAN class="keyword">end</SPAN></CODE> の計算を完了し、最終的なリスト <CODE>[1&nbsp;4&nbsp;9]</CODE> として結果が出ます。 </P><P><A href="node8.html#concurrentfib">Figure&nbsp;8.2</A> で示されるプログラムは並行分割統治プログラムで、それは <EM>Fibonacci</EM> 関数を計算するかなり非効率的なやり方です。このプログラムは指数的な数のスレッドを作ります！並行スレッドを生成するのがいかに容易かを見ましょう。あなたはこのプログラムをあなたの Oz の環境がどの程度多くのスレッドを生成出来るかのテストに使う事が出来ます。次を試して見て下さい </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{Fib&nbsp;25}}</CODE></BLOCKQUOTE><P> </P><P>Oz メニューで panel プログラムを使ってスレッドを見る事が出来ます。うまく動いたら、もっと大きな数で試してみて下さい。panel は <A href="node8.html#threads">Figure&nbsp;8.3</A> に示されています。 </P><P></P><DIV class="figure" id="concurrentfib"><HR><P><A name="concurrentfib"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Fib</SPAN>&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Fib&nbsp;X<SPAN class="keyword">-</SPAN>1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;{Fib&nbsp;X<SPAN class="keyword">-</SPAN>2}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.2:</STRONG> 並行 Fibonacci 関数</P><HR></DIV><P> </P><P></P><DIV class="figure" id="threads"><HR><P><A name="threads"></A></P></DIV><DIV align="center"><IMG alt="" src="thread.gif"></DIV><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.3:</STRONG> Mozart Panel で <CODE>{Fib&nbsp;26&nbsp;X}</CODE> の作るスレッドを見る</P><HR></DIV><P> </P><P>Oz での明示的なスレッド生成のアイディアはプログラマに彼/彼女のアプリケーションをモジュールとして構築する事を可能にします。この点において Mozart システムはとりわけ優れています。スレッドは 100000 個を生成出来る程に安価です。Mozart 1.0 でのスレッド生成は Java JDK 1.2 に比べて約60倍高速です。並行性があなたのプログラムの構造を易しくするなら、遠慮なくそれを使いましょう。しかしながら同じ構造を持っているのであれば線形プログラムの方が並行プログラムより常により速いです。<A href="node8.html#concurrentfib">Figure&nbsp;8.2</A> の <CODE>Fib</CODE> プログラムは <CODE><SPAN class="keyword">thread</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> を除いた方が速いです。それゆえ、ただ並行性が楽しいからという理由ではなく、アプリケーションが必要とする時のみスレッドを生成するようにしましょう。 </P><DIV id="section.concurrency.time"><H2><A name="section.concurrency.time">8.1 Time</A></H2><P>モジュール <A href="../base/time.html#section.control.time"><CODE>Time</CODE></A> では、いくつもの有用なソフトリアルタイム手続きを見られます。それらは: </P><UL><LI><P><CODE>{Alarm&nbsp;I&nbsp;?U}</CODE> 即座に自身のスレッドを作り、<CODE>U</CODE> を <CODE><SPAN class="keyword">unit</SPAN></CODE> に <CODE>I</CODE> ミリ秒後に束縛します。 </P></LI><LI><P><CODE>{Delay&nbsp;I}</CODE> スレッドの実行を最低でも <CODE>I</CODE> ミリ秒一時停止し、<CODE><SPAN class="keyword">skip</SPAN></CODE> に減らします。 </P></LI></UL><P> </P><P></P><DIV class="figure" id="pingpong"><HR><P><A name="pingpong"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Ping</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N<SPAN class="keyword">==</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'ping&nbsp;terminated'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;{Delay&nbsp;500}&nbsp;{Browse&nbsp;ping}&nbsp;{Ping&nbsp;N<SPAN class="keyword">-</SPAN>1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Pong</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;N&nbsp;1&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Delay&nbsp;600}&nbsp;{Browse&nbsp;pong}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'pong&nbsp;terminated'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'game&nbsp;started'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Ping&nbsp;50}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Pong&nbsp;50}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.4:</STRONG> 'Ping Pong' プログラム</P><HR></DIV><P> </P><P><A href="node8.html#pingpong">Figure&nbsp;8.4</A> で示されるプログラムは2つのスレッドを開始し、1つは <CODE>ping</CODE> を500ミリ秒後に定期的に表示し、他方は <CODE>pong</CODE> を600秒後に表示します。いくつかの <CODE>ping</CODE> は周期の違いのためにそれぞれの後に即座に表示されるでしょう。 </P><H3><A name="label48">8.1.1スタンドアロンなアプリケーションを作る</A></H3><P>Mozart でスタンドアロンなアプリケーションを作るのは簡単です。私達はこの事を <A href="node8.html#pingpong">Figure&nbsp;8.4</A> のプログラムを <A href="node8.html#pingpong1">Figure&nbsp;8.5</A> に示されるプログラムのファンクタを作る事によってスタンドアロンにする事によって見せ、それをファイル <CODE>PingPong<SPAN class="keyword">.</SPAN>oz</CODE> に保存します。その後、次のコマンドを使って下さい: </P><BLOCKQUOTE class="code"><CODE>&nbsp;ozc&nbsp;<SPAN class="keyword">-</SPAN>x&nbsp;PingPong<SPAN class="keyword">.</SPAN>oz&nbsp;</CODE></BLOCKQUOTE><P></P><P> そしたら PingPong とシェルに打ち込んでプログラムを開始して下さい。<A href="node8.html#label50"><SUP>1</SUP></A></P><P></P><DIV class="figure" id="pingpong1"><HR><P><A name="pingpong1"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Browser(browse:Browse)&nbsp;<SPAN class="comment">% Browser モジュールから Browse をインポート<BR></SPAN><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Ping</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N<SPAN class="keyword">==</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'ping&nbsp;terminated'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;{Delay&nbsp;500}&nbsp;{Browse&nbsp;ping}&nbsp;{Ping&nbsp;N<SPAN class="keyword">-</SPAN>1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Pong</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;N&nbsp;1&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Delay&nbsp;600}&nbsp;{Browse&nbsp;pong}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'pong&nbsp;terminated'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'game&nbsp;started'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Ping&nbsp;50}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Pong&nbsp;50}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.5:</STRONG> スタンドアロン 'Ping Pong' プログラム</P><HR></DIV><P> </P></DIV><DIV id="section.concurrency.stream"><H2><A name="section.concurrency.stream">8.2 Stream Communication</A></H2><P>Oz のデータフローの性質は生産者-消費者パターンでストリームを通したやり取りを行うスレッドを書くのを容易にしてくれます。ストリームは生産者スレッドによって漸増的に作られ、その後に消費者スレッドによって消費されるリストです。スレッドはストリームの同じ要素を消費します。例として <A href="node8.html#sumelements">Figure&nbsp;8.6</A> のプログラムはストリームコミュニケーションの例で、そこでは生産者が数のリストを作り、消費者が全ての数を足し合わせています。 </P><P></P><DIV class="figure" id="sumelements"><HR><P><A name="sumelements"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Generator</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">&gt;</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;N<SPAN class="keyword">|</SPAN>{Generator&nbsp;N<SPAN class="keyword">-</SPAN>1}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sum1</SPAN>&nbsp;L&nbsp;A}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;L<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;A<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xs&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Sum1&nbsp;Xs&nbsp;A<SPAN class="keyword">+</SPAN>X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sum</SPAN>&nbsp;L}&nbsp;{Sum1&nbsp;L&nbsp;0}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.6:</STRONG> リストの要素の足し合わせ</P><HR></DIV><P> </P><P>以下のプログラムを走らせて上のプログラムを試して下さい: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Sum&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Generator&nbsp;150000}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> </P><P><CODE>11250075000</CODE> という数が出てくるでしょう。ストリームコミュニケーションの働きについて理解しましょう。以下の例でvolvoを作る時、生産者は漸増的に要素のストリーム(リスト)を作ります。これは一般に性急(eager)な流儀です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Producer</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;volvo<SPAN class="keyword">|</SPAN>{Producer&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>消費者はストリームをアイテムが到着するまで待ち、到着するとアイテムは次の様に消費されます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;Ls&nbsp;<SPAN class="keyword">...</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Ls&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;volvo<SPAN class="keyword">|</SPAN>Lr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>'Consume volvo'</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Consumer&nbsp;Lr}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><EM>case 文</EM>のデータフローの振る舞いは消費者をストリームの次のアイテムが到着するまで一時停止させます。再帰呼び出しは消費者に動作の繰り返しを可能にします。以下のパターンは反復を代わりに使う事により再帰の使用を避けています: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;Ls&nbsp;<SPAN class="keyword">...</SPAN>}<BR>&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Ls<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Item}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Item&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;volvo&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><I>Consume volvo</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><A href="node8.html#volvos">Figure&nbsp;8.7</A> はこのパターンを使った簡単な例を示しています。消費者は受け取った車(volvo)を数えます。<CODE>1000</CODE> の車を受け取るごとに、Browser にメッセージを表示します。 </P><P></P><DIV class="figure" id="volvos"><HR><P><A name="volvos"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Producer</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">&gt;</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volvo<SPAN class="keyword">|</SPAN>{Producer&nbsp;N<SPAN class="keyword">-</SPAN>1}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ConsumerN</SPAN>&nbsp;Ls&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Ls&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;volvo<SPAN class="keyword">|</SPAN>Lr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;1000&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'riding&nbsp;a&nbsp;new&nbsp;volvo'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ConsumerN&nbsp;Lr&nbsp;N<SPAN class="keyword">+</SPAN>1}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ConsumerN&nbsp;{List<SPAN class="keyword">.</SPAN>drop&nbsp;Ls&nbsp;1}&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;Ls}&nbsp;{ConsumerN&nbsp;Ls&nbsp;1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.7:</STRONG> volvo を生産</P><HR></DIV><P> </P><P>このプログラムは以下を使って走らせます: </P><BLOCKQUOTE class="code"><CODE>{Consumer&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Producer&nbsp;10000}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> </P><P class="warning"><STRONG>注意:</STRONG>文を emulator にフィードすると、それは自身のスレッドで実行されます。それゆえ、上の文をフィードすると2つのスレッドが作られます。メインは消費者のためのもので、フォークしたスレッドは生産者のためのものです。 </P><P>消費者は<EM>再帰</EM>パターンを使って書かれている事に注目して下さい。私達はこのプログラムを繰り返しの <CODE>ForAll<SPAN class="keyword">/</SPAN>2</CODE> 構造を使ってプログラム出来るでしょうか？消費者が結果を次の再帰に受け渡すための追加の引数 <I>N</I> を伴っているのでこれは不可能です(訳注:この様な引数はaccumulaterと呼ばれ関数型プログラミングでは一般的に使われます)。この引数は<EM>状態</EM>の一種に対応します。一般的に、2つの解法があります。<A href="node9.html#section.stateful.cell">Section&nbsp;9.4</A>で行われるようにステートフル(mutable 代入可能)なデータ構造を導入するか、状態を持ち回る別のイテレータ(iterator 反復子)を定義するかです。私達の場合、目的に適するいくつかの反復子はモジュール <CODE>List</CODE> にあります。最初に、私達は volvo 以外をフィルターして除去する反復子を必要とします。<CODE>Ys</CODE> に Boolean 関数として使われる手続き <CODE>P<SPAN class="keyword">/</SPAN>2</CODE> を満たす全要素を出力する <CODE>{Filter&nbsp;Xs&nbsp;P&nbsp;?Ys}</CODE> を使う事が出来ます。2番目の構築は <CODE>{List<SPAN class="keyword">.</SPAN>forAllInd&nbsp;Xs&nbsp;P}</CODE> で、それは <CODE>ForAll</CODE> に似ていますが <CODE>P<SPAN class="keyword">/</SPAN>2</CODE> は最初の引数としてリストの現在の要素の <CODE>1</CODE> から始まるインデックスを取り、2番目の引数としてリストの要素を取ります。これがプログラムです: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;Ls}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IsVolvo</SPAN>&nbsp;X}&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;volvo&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Ls1<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;Ls1&nbsp;=&nbsp;{Filter&nbsp;Ls&nbsp;IsVolvo}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{List<SPAN class="keyword">.</SPAN>forAllInd&nbsp;Ls1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;N&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;1000&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'riding&nbsp;a&nbsp;new&nbsp;volvo'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.concurrency.priority"><H2><A name="section.concurrency.priority">8.3スレッド優先度(thread priority)とリアルタイム</A></H2><P>以下の文を使ってプログラムを走らせてみましょう: </P><BLOCKQUOTE class="code"><CODE>{Consumer&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Producer&nbsp;5000000}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> </P><P>panel に切り替えてプログラムのメモリの振る舞いを観察しましょう。あなたはすぐにこのプログラムが良い振る舞いをしていない事に気付くでしょう。その理由は非同期メッセージパッシング(asynchronous message passing)です。生産者がメッセージを送った時、すなわちストリームに新しい要素を生成した時、それが消費者が消費するより速いレートの場合、システムが壊れ始めるまでより多いバッファを必要とし続けます。<A href="node8.html#label51"><SUP>2</SUP></A> この問題を解決するためのいくつかの方法があります。一つは生産者と消費者の間で有界バッファ(bounded buffer)を作る事で、これは後で論じます。他の方法はスレッドの実行スピードをスレッド優先度の変更によって変える事で、消費者が生産者より多くの時分割を得るようにする事です。 </P><P>モジュール <CODE>Thread</CODE> と <CODE>Property</CODE> はスレッドへのいくつもの適切な操作を提供します。これらのうちいくつかは <A href="node8.html#threadtable">Table&nbsp;8.1</A> で分類されます。 </P><P></P><DIV class="table" id="threadtable"><HR><P><A name="threadtable"></A></P></DIV><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>手続き</P></TH><TH><P>記述</P></TH></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>state&nbsp;<SPAN class="keyword">+</SPAN>T&nbsp;?A}</CODE></P></TD><TD><P><CODE>T</CODE> の現在の状態を返す</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>suspend&nbsp;<SPAN class="keyword">+</SPAN>T}</CODE></P></TD><TD><P><CODE>T</CODE> を一時停止する</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>resume&nbsp;<SPAN class="keyword">+</SPAN>T}</CODE></P></TD><TD><P><CODE>T</CODE> を再開する</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>terminate&nbsp;<SPAN class="keyword">+</SPAN>T}</CODE></P></TD><TD><P><CODE>T</CODE> を終了する</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>injectException&nbsp;<SPAN class="keyword">+</SPAN>T&nbsp;<SPAN class="keyword">+</SPAN>E}</CODE></P></TD><TD><P><CODE>T</CODE> で例外 <CODE>E</CODE> を発生させる</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>this&nbsp;<SPAN class="keyword">+</SPAN>T}</CODE></P></TD><TD><P>現在のスレッド <CODE>T</CODE> を返す</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>setPriority&nbsp;<SPAN class="keyword">+</SPAN>T&nbsp;<SPAN class="keyword">+</SPAN>P}</CODE></P></TD><TD><P><CODE>T</CODE> の優先度を設定する</P></TD></TR><TR valign="top"><TD><P><CODE>{Thread<SPAN class="keyword">.</SPAN>setThisPriority&nbsp;<SPAN class="keyword">+</SPAN>P}</CODE></P></TD><TD><P>現在のスレッドの優先度を設定する</P></TD></TR><TR valign="top"><TD><P><CODE>{Property<SPAN class="keyword">.</SPAN>get&nbsp;priorities&nbsp;?Pr&nbsp;}</CODE></P></TD><TD><P>システムの優先度の比を取得する </P></TD></TR><TR valign="top"><TD><P><CODE>{Property<SPAN class="keyword">.</SPAN>put&nbsp;priorities(high:<SPAN class="keyword">+</SPAN>X&nbsp;medium:<SPAN class="keyword">+</SPAN>Y)}</CODE></P></TD><TD><P>システムの優先度の比を設定する</P></TD></TR></TABLE><DIV class="table"><P class="caption"><STRONG>Table&nbsp;8.1:</STRONG> スレッドの操作</P><HR></DIV><P> </P><P>Oz は3つの優先度レベルを持っています。システム手続き </P><BLOCKQUOTE class="code"><CODE>{Property<SPAN class="keyword">.</SPAN>put&nbsp;priorities(high:X&nbsp;medium:Y)}</CODE></BLOCKQUOTE><P> </P><P>はプロセッサ時間の比を高優先度(high)のスレッド:中優先度(medium)のスレッドで <CODE>X:1</CODE> と設定します。これは同時にプロセッサ時間の比を中優先度(medium):低優先度(low)のスレッドで <CODE>Y:1</CODE> と設定します。<CODE>X</CODE> と <CODE>Y</CODE> は整数です。そのため、もし私達が次を実行すると </P><BLOCKQUOTE class="code"><CODE>{Property<SPAN class="keyword">.</SPAN>put&nbsp;priorities(high:10&nbsp;medium:10)}</CODE></BLOCKQUOTE><P> </P><P>走る事の出来る高優先度スレッドの <CODE>10</CODE> 回の時分割の割り当てごとにシステムは中優先度のスレッドを1回割り当て、同様の事が中優先度と低優先度の間で行われます。同じ優先度レベルでは、スケジューリングは公平でラウンドロビンです。さあ、私達の生産者-消費者プログラムを動くようにしましょう。私達は生産者に低い優先度を与え、消費者に高い優先度を与えます。優先度の比を <CODE>10:1</CODE> と <CODE>10:1</CODE> に設定します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Property<SPAN class="keyword">.</SPAN>put&nbsp;threads&nbsp;priorities(high:10&nbsp;medium:10)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Thread<SPAN class="keyword">.</SPAN>setThisPriority&nbsp;low}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;{Producer&nbsp;5000000}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Thread<SPAN class="keyword">.</SPAN>setThisPriority&nbsp;high}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Consumer&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.concurrency.demanddriven"><H2><A name="section.concurrency.demanddriven">8.4要求駆動(demand-driven)実行</A></H2><P>やや過激な代替の解法は、生産者を遅延実行(lazy)にし、消費者が要求した時のみアイテムを生産する事です。消費者はこの場合、未束縛の変数(空の箱)によるストリームを構築します。生産者は未束縛の変数(空の箱)がストリームに見えるまで待ちます。それから変数を束縛します(箱を埋めます)。生産者の一般的なパターンは以下になります。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Producer</SPAN>&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="string">'Produce&nbsp;I'</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X=I&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Producer&nbsp;Xr}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>消費者の一般的なパターンは以下になります。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;X&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="string">'Consume&nbsp;X'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{Consumer&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xr}<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;</CODE></BLOCKQUOTE><P> </P><P><A href="node8.html#volvos2">Figure&nbsp;8.8</A> で見るプログラムは <A href="node8.html#volvos">Figure&nbsp;8.7</A> のプログラムの要求駆動版です。あなたはこれを大量のvolvoで走らせられます！ </P><P></P><DIV class="figure" id="volvos2"><HR><P><A name="volvos2"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Producer</SPAN>&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;X&nbsp;=&nbsp;volvo&nbsp;{Producer&nbsp;Xr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'end&nbsp;of&nbsp;line'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;N&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N<SPAN class="keyword">=&lt;</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Xs=nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;=&nbsp;Xs&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;volvo&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;1000&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'riding&nbsp;a&nbsp;new&nbsp;volvo'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Consumer&nbsp;N<SPAN class="keyword">-</SPAN>1&nbsp;Xr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Consumer&nbsp;N&nbsp;Xr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Consumer&nbsp;10000000&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Producer&nbsp;$}&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.8:</STRONG> volvo を遅延的に生産する</P><HR></DIV><P> </P><H3><A name="label49">8.4.1フューチャ(future) </A></H3><P>プログラムを要求駆動計算にするのに他の方法があります。<EM>future</EM> の記法と <CODE>ByNeed</CODE> プリミティブ操作を使う事です。フューチャ(future)は論理変数のリードオンリー版です。例として変数 <CODE>X</CODE> のフューチャを作るのに、私達は操作 <CODE><SPAN class="keyword">!!</SPAN></CODE> でフューチャ <CODE>Y</CODE> を作ります。 </P><BLOCKQUOTE class="code"><CODE>&nbsp;Y&nbsp;=&nbsp;<SPAN class="keyword">!!</SPAN>X&nbsp;</CODE></BLOCKQUOTE><P> </P><P> スレッドがフューチャの値を使おうとする時、例えば <CODE>Y</CODE> を使うときは <CODE>X</CODE> が束縛されるまで一時停止するでしょう。 </P><P>手続きを遅延的に実行しようとする一つの方法、つまり、要求駆動の様式で行う事とは、操作 <CODE>{ByNeed&nbsp;<SPAN class="keyword">+</SPAN>P&nbsp;?F}</CODE> を使う事です。<CODE>ByNeed</CODE> は1引数の手続き <CODE>P</CODE> を取り、フューチャ <CODE>F</CODE> を返します。スレッドが <CODE>F</CODE> の値にアクセスしようとする時、手続き <CODE>{P&nbsp;X}</CODE> が呼び出され、結果の値 <CODE>X</CODE> が <CODE>F</CODE> に束縛されます。これは私達に直接的な様式での要求駆動計算を可能にします。例として次をフィードして下さい </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Y<BR>{ByNeed&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;X=1&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;Y}<BR>{Browse&nbsp;Y}</CODE></BLOCKQUOTE><P> </P><P>私達は <CODE>Y</CODE> がフューチャになる事を観察するでしょう、つまり私達は <CODE>Y<SPAN class="keyword">&lt;</SPAN>Future<SPAN class="keyword">&gt;</SPAN></CODE> と Browser で見るでしょう。もし私達が <CODE>Y</CODE> の値にアクセスしようとしれば、それは <CODE>1</CODE> に束縛されるでしょう。<CODE>Y</CODE> にアクセスする一つの方法は、手続きの生成を発火(trigger)する操作 <CODE>{Wait&nbsp;Y}</CODE> を行う事です。 </P><P> 今、私達は <A href="node8.html#volvos2">Figure&nbsp;8.8</A> のプログラムを <A href="node8.html#volvos3">Figure&nbsp;8.9</A> の様に書き直せます。これは <A href="node8.html#volvos">Figure&nbsp;8.7</A> とよく似て見えます。 </P><DIV class="figure" id="volvos3"><HR><P><A name="volvos3"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Producer</SPAN>&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;volvo<SPAN class="keyword">|</SPAN>{ByNeed&nbsp;{Producer&nbsp;Xr}&nbsp;$}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Consumer</SPAN>&nbsp;N&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N<SPAN class="keyword">&gt;</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">==</SPAN>volvo&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;1000&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'riding&nbsp;a&nbsp;new&nbsp;volvo'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Consumer&nbsp;N<SPAN class="keyword">-</SPAN>1&nbsp;Xr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;{Consume&nbsp;N&nbsp;Xr}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Consumer&nbsp;10000000&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Producer&nbsp;$}&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.9:</STRONG> volvo を <CODE>ByNeed</CODE> を使って生産する </P><HR></DIV><P> </P></DIV><DIV id="section.concurrency.termination"><H2><A name="section.concurrency.termination">8.5スレッド終了の検知</A></H2><P>私達はスレッドが文 <CODE><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE> を使ってどの様に分岐するかを見ました。ここで思いつく自然な質問は、どうやって分岐したスレッドを元の制御のスレッドに合流させて戻すかです。実際には、これは複数のスレッドの終了検知の特別な場合で、他のスレッドをそのイベントを待つようにします。Oz はデータフロー言語なので、一般的な枠組みはとても簡単です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>T1</I><CODE>&nbsp;</CODE><I>X1</I><CODE>=<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>T2</I><CODE>&nbsp;</CODE><I>X2</I><CODE>=</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>TN</I><CODE>&nbsp;</CODE><I>XN</I><CODE>=</CODE><I>XN-1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>{Wait&nbsp;</CODE><I>XN</I><CODE>}<BR></CODE><I>MainThread</I></BLOCKQUOTE><P> </P><P>全てのスレッドが終了する時、変数 <I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I> は一緒に併合され <CODE><SPAN class="keyword">unit</SPAN></CODE> に束縛されます。<CODE>{Wait&nbsp;</CODE><I>XN</I><CODE>}</CODE> sは <I>XN</I> が束縛されるまでメインのスレッドを一時停止させます。 </P><P><A href="node8.html#concurrentcomp">Figure&nbsp;8.10</A> で私達は、上の筋書きに沿った制御構造の並行組み合わせを実装する、高階の構造(コンビネータ)を定義します。それは引数無しの手続きのリストを単一の引数として取ります。それが実行される時、手続きは並行に分岐します。次の文はリスト中の全ての手続きが終了した時のみ実行されます。 </P><P></P><DIV class="figure" id="concurrentcomp"><HR><P><A name="concurrentcomp"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Conc1</SPAN>&nbsp;Ps&nbsp;I&nbsp;O}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Ps&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;P<SPAN class="keyword">|</SPAN>Pr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{P}&nbsp;M&nbsp;=&nbsp;I&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Conc1&nbsp;Pr&nbsp;M&nbsp;O}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;O&nbsp;=&nbsp;I<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Conc</SPAN>&nbsp;Ps}&nbsp;{Wait&nbsp;{Conc1&nbsp;Ps&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;$}}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.10:</STRONG> 並行組み合わせ</P><HR></DIV><P></P><P> プログラム <A href="node8.html#pingpong1">Figure&nbsp;8.5</A> は <CODE>Ping</CODE> と <CODE>Pong</CODE> スレッドが終了した時には適切に終了しません。このプログラムに今手を打つ事が出来ます。私達が <CODE>Application<SPAN class="keyword">.</SPAN>exit<SPAN class="keyword">/</SPAN>1</CODE> を使えば、スタンドアロンのアプリケーションは残ったスレッドをアボートして終了します。<CODE>Ping</CODE> と <CODE>Pong</CODE> のスレッドが終了した時のみメインのスレッドが終了するように変更する事も出来ます。これは <A href="node8.html#pingpong2">Figure&nbsp;8.11</A> で示されます。 </P><P></P><DIV class="figure" id="pingpong2"><HR><P><A name="pingpong2"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Browser(browse:Browse)&nbsp;<SPAN class="comment">% Browser モジュールから Browse をインポート<BR></SPAN>&nbsp;&nbsp;&nbsp;Application<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Ping</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;N<SPAN class="keyword">==</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'ping&nbsp;terminated'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;{Delay&nbsp;500}&nbsp;{Browse&nbsp;ping}&nbsp;{Ping&nbsp;N<SPAN class="keyword">-</SPAN>1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Pong</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;N&nbsp;1&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Delay&nbsp;600}&nbsp;{Browse&nbsp;pong}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'pong&nbsp;terminated'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X1&nbsp;X2<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">'game&nbsp;started'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Ping&nbsp;50}&nbsp;X1=<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Pong&nbsp;50}&nbsp;X2=X1&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Wait&nbsp;X2}<BR>&nbsp;&nbsp;&nbsp;{Application<SPAN class="keyword">.</SPAN>exit&nbsp;0}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;8.11:</STRONG> スタンドアロンの 'Ping Pong' プログラム</P><HR></DIV><P></P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node7.html#chapter.modules">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node9.html#chapter.stateful">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label50">1. </A>このプログラムを終了させるにはOSのシェルでCONTROL-Cを実行して下さい。後で適切に終了させる方法を見ます。</DIV><DIV class="footnote"><A name="label51">2. </A>皮肉な事に Mozart システムで分散プログラミングの機能を使う時には、サイト間でのストリームコミュニケーションの方がよく働きます、これはデザインされたフロー制御の機構がネットワークバッファが一杯の時に手続きを一時停止させるためです。</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
