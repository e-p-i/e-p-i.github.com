<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>3 Basics</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.opi">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.equality">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.basics"><H1><A name="chapter.basics">3 Basics</A></H1><P>まず最初は、私達が使う Oz のプログラミングスタイルをシーケンシャルなものに制限しましょう。この段階では、あなたは Oz の計算を1つの文(statement)を次々に実行していくシーケンシャルなプロセスとして振る舞うものと考える事が出来ます。私達はこのプロセスを <EM>スレッド(thread)</EM> と呼びます。スレッドは<EM>ストア(store)</EM>にアクセスします。ストアは中の情報を読み込み、追加、更新する事で操作する事が出来ます。情報は<EM>変数(variable)</EM>の概念によってアクセスされます。スレッドは、そのスレッドから可視(visible)である変数を通じて情報に直接的にまたは間接的にアクセス出来ます。Oz の変数は<EM>単一代入(single-assignment)</EM>変数、より適切に言うと論理変数です。CやJavaの様な命令型(imprerative)言語では、変数は複数回代入を行えます。対照的に、単一代入変数は一度のみ代入が行えます。この概念はデータフロー言語と並行論理プログラミング言語を含む多くの言語で知られています。単一代入変数はそのライフサイクルの中でいくつかの段階を持っています。最初、それは未知の値として導入され、後に値を代入される事がありその場合は変数は<EM>束縛された(bound)</EM>状態となります。一度変数が束縛されると、変更は出来ません。<EM>論理変数(logic variable)</EM>は他の変数と同一視される事も可能な単一代入変数です。論理変数を使う事は、状態変化を行う事が不可能である、という事を意味しません。なぜなら後で見るように、変数は状態を持つセルに束縛でき、セルの内容は変更可能だからです。</P><P>スレッドが以下の文: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>を実行すると、3つの単一代入変数 <CODE>X</CODE>, <CODE>Y</CODE>, <CODE>Z</CODE> が導入され、これらの変数のスコープで文 <CODE>S</CODE> が実行されます。変数は通常は大文字(upper-case)の綴りで始まり、それ以降は任意の数の英数字を続ける事が出来ます。変数はバッククォート(`)で囲まれた印字可能な文字列としても表せます。例: <CODE><SPAN class="string">`this&nbsp;$&nbsp;is&nbsp;a&nbsp;variable`</SPAN></CODE> <CODE>S</CODE> を実行する前、宣言された変数は紐付けられた値を持たないでしょう。この様な変数を<EM>未束縛(unbound)</EM>と呼びます。Oz プログラムでは、後で見る事になる特定のパターンマッチングが構築するものを除いて、いかなる変数も必ず導入されていなければなりません。 </P><P>宣言の別の形式: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;S</CODE></BLOCKQUOTE><P> </P><P>これは <CODE>X</CODE>, <CODE>Y</CODE>, <CODE>Z</CODE> が <CODE>S</CODE> 中の全域で可視になる端が開いた宣言で、<CODE>S</CODE> に続く文でも同じ綴りの変数が宣言されて上書きされない限り有効となります。この時、<CODE>X</CODE>, <CODE>Y</CODE>, <CODE>Z</CODE> はグローバル変数となります</P><H2><A name="label14">3.1Oz の主要な型(type)</A></H2><P></P><DIV class="figure" id="typehier"><HR><P><A name="typehier"></A></P><P> </P><DIV align="center"><IMG alt="" src="image33.gif"></DIV><P> </P><P class="caption"><STRONG>Figure&nbsp;3.1:</STRONG> Oz の型ヒエラルキー</P><HR></DIV><P> </P><P>Oz は動的型付けを行う言語です。<A href="node3.html#typehier">Figure&nbsp;3.1</A> は Oz の型ヒエラルキーを示しています。どの変数も、値を得る時には、これらの型の中からから一つの値に束縛されるでしょう。多分、<EM>Chunk</EM>, <EM>Cell</EM>, <EM>Space</EM>, <EM>FDInt</EM>, <EM>Name</EM> を除いて、これらの型のほとんどは経験あるプログラマにはなじみがあるものでしょう。私達はやがてこれら全ての型について論じます。せっかちな読者のためにここでいくつかのヒントを与えます。<EM>Chunk(チャンク)</EM> データ型はユーザに新しい抽象データ型を導入する事を可能にします。<EM>Cell(セル)</EM> は状態コンテナと状態変更のプリミティブな概念です。<EM>Space(空間)</EM> は探索のテクニックを使って進んだ問題を解くのに必要となります。<EM>FDInt</EM> は制約プログラミングと制約充足によく使われる有限ドメインの型です。<EM>Name(名前)</EM> は偽造出来ない匿名トークンを導入します。 </P><P>言語が動的型付けである、というのは変数が導入された時にはその型は値と同様に未知である、という意味においてです。変数が Oz の値に束縛された時のみ、その型は決定されたものになります。 </P><H2><A name="label15">3.2情報を追加する</A></H2><P>Oz において、ストアに情報を追加する、言い換えると変数を値に束縛するのにはいくつかの手段があります。最もよく使われる形式は<EM>等価(equality)</EM>中置演算子(infix operator)である <CODE>=</CODE> を使う事です。例として、変数 <CODE>X</CODE> が以下の様に宣言されて与えられた場合: </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;1</CODE></BLOCKQUOTE><P> </P><P>これは未束縛の変数 <CODE>X</CODE> を整数 <CODE>1</CODE> に束縛し、この情報をストアに追加します。今、もし <CODE>X</CODE> が既に値 <CODE>1</CODE> に束縛されているのであれば、この操作は <CODE>X</CODE> に対するテストとして振る舞います。もし <CODE>X</CODE> が既に整合性の無い値(<CODE>1</CODE>以外の値)に束縛されているとすると、適切な<EM>例外(exception)</EM>が発生します(be raised)。例外制御は後で記述されています。 </P><H2><A name="label16">3.3構造同等性(structual equality)とデータ型(data type)</A></H2><P><A href="node3.html#typehier">Figure&nbsp;3.1</A> で <EM>Number</EM> と <EM>Record</EM> から始まるヒエラルキーは、Oz のデータ型についてそのメンバー(値)が等しいのはそれらが構造的に類似である時のみであると定義しています。例えば2つの数値はそれらが同じ型、もしくは一方が他方のサブ型で、値が等しい場合に等価です。例えば、両者が integer で同じ数値であるか、両者がリストでそれらの head 要素が同じで続く tail もそれぞれ同じである場合です。構造同等性は、値が物理メモリ中で別の位置に存在するレプリカであった場合でも等価であるという事を許します。 </P><H2><A name="label17">3.4数値(number)</A></H2><P>以下のプログラムは3つの変数 <CODE>I</CODE>,<CODE>F</CODE>, <CODE>C</CODE> を導入します。<CODE>I</CODE> は整数(integer)に、<CODE>F</CODE> は浮動小数(float)に、<CODE>C</CODE> は文字(character) <SPAN class="key">t</SPAN> にこの順序で紐付けます。それから <CODE>I</CODE>,<CODE>F</CODE>, <CODE>C</CODE> を含むリストを表示します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;I&nbsp;F&nbsp;C&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;F&nbsp;=&nbsp;5<SPAN class="keyword">.</SPAN>5<BR>&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;<SPAN class="string">&amp;t</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;[I&nbsp;F&nbsp;C]}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Oz は2進(binary)、8進(octal)、10進(decimal)、16進(hexadecimal)表記を整数用にサポートしており、それらは任意の大きさを持つ事が出来ます。8進表記は頭が <SPAN class="key">0</SPAN> で始まり、16進表記は頭が <SPAN class="key">0x</SPAN> か <SPAN class="key">0X</SPAN> で始まります。浮動小数は整数とは違い、小数点を持たなければなりません。浮動小数の他の例は <CODE><SPAN class="keyword">~</SPAN></CODE> が負を表す単項演算子である事に見られます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">~</SPAN>3<SPAN class="keyword">.</SPAN>141&nbsp;&nbsp;&nbsp;4<SPAN class="keyword">.</SPAN>5E3&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">~</SPAN>12<SPAN class="keyword">.</SPAN>0e<SPAN class="keyword">~</SPAN>2</CODE></BLOCKQUOTE><P> </P><P>Oz では、自動的な型の変換は無いので、<CODE>5<SPAN class="keyword">.</SPAN>0&nbsp;=&nbsp;5</CODE> は例外を発生させるでしょう。当然、明示的な型の変換を行うプリミティブな手続きがあります。これらとその他多くが <A href="bib.html#schulte98">[Shu98]</A> で見る事が出来ます。文字は整数のサブ型で、<CODE>0<SPAN class="keyword">,</SPAN>&nbsp;<SPAN class="keyword">...,</SPAN>&nbsp;255</CODE> までの範囲のものとなっています。Unicode ではなく ISO 8859-1 が使われています。印字可能な文字は外部表現(external representation)を持ち、例えば <CODE><SPAN class="string">&amp;0</SPAN></CODE> は実際には整数 <CODE>48</CODE> で <CODE><SPAN class="string">&amp;a</SPAN></CODE> は <CODE>97</CODE> です。いくつかの制御文字は同様に外部表現を持っています。例: <CODE><SPAN class="string">&amp;\n</SPAN></CODE> は改行。全ての文字は <CODE>&amp;\</CODE><EM>ooo</EM> として記述できます(<EM>o</EM> は8進数)。 </P><P>文字、整数、浮動小数の操作はライブラリモジュール <A href="../base/char.html#section.text.characters"><CODE>Char</CODE></A>, <A href="../base/float.html#section.numbers.floats"><CODE>Float</CODE></A>, <A href="../base/int.html#section.numbers.integers"><CODE>Int</CODE></A> で目にする事が出来ます。付加されるジェネリックな操作はモジュール <A href="../base/number.html#section.numbers.general"><CODE>Number</CODE></A> で目にする事が出来ます。 </P><H2><A name="label18">3.5リテラル(literal)</A></H2><P>他の重要な原始型(atomic type)、すなわちそのメンバーが内部表現を持たないものは、リテラルのカテゴリーに属します。リテラルはアトム(atom)と名前(name)に分けられます。アトムは、小文字(lower-case)の綴りで始まる英数字の文字列、もしくはクォート(')で囲まれた任意の印字可能な文字列から作られた記号的(symbolic)なエンティティです。例: </P><BLOCKQUOTE class="code"><CODE>a&nbsp;&nbsp;&nbsp;foo&nbsp;&nbsp;&nbsp;<SPAN class="string">'='</SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="string">':='</SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="string">'OZ&nbsp;3.0'</SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN></CODE></BLOCKQUOTE><P> </P><P>アトムは辞書式の順序を持っています。 </P><P>他の基礎的なエンティティは<CODE>名前(Name)</CODE>です。名前を作る唯一の手段は、手続き <CODE>{NewName&nbsp;X}</CODE> を呼び出す事で、ここで <CODE>X</CODE> が世界でただ一つと保証された新しい名前に紐付けられます。名前は偽造も表示も出来ません。後で見るように、名前は Oz プログラムのセキュリティで重要な役目を果たします。<CODE>Name</CODE> のサブ型 <CODE>Bool</CODE> は予約されたキーワード <CODE><SPAN class="keyword">true</SPAN></CODE> と <CODE><SPAN class="keyword">false</SPAN></CODE> を持つ再定義から保護された2つの名前から成っています。それゆえ、ユーザのプログラムはそれらを再定義出来ず、それらの再定義をあてにした全てのプログラムは使い物になりません。型 <CODE>Unit</CODE> は単一の名前 <CODE><SPAN class="keyword">unit</SPAN></CODE> から成ります。これは多くの並行プログラムにおいて同期トークンとして使われます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;B&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;foo<BR>&nbsp;&nbsp;&nbsp;{NewName&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;[X&nbsp;Y&nbsp;B]}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H2><A name="label19">3.6レコード(record)とタプル(tuple 組)</A></H2><P>レコードは構造的に合成されたエンティティです。レコードは<EM>ラベル(label)</EM>と決まった数のコンポーネントか引数を持ちます。可変引数を取る<EM>オープンレコード(open record)</EM>と呼ばれるレコードもあります。今は、'closed'なレコードに限定しましょう。以下がレコードとなります: </P><BLOCKQUOTE class="code"><CODE>tree(key:&nbsp;I&nbsp;value:&nbsp;Y&nbsp;left:&nbsp;LT&nbsp;right:&nbsp;RT)</CODE></BLOCKQUOTE><P> </P><P>4つの引数を持ち、そのラベルは <CODE>tree</CODE> です。それぞれの引数は<EM>フィールド名:フィールド(Feature:Field)</EM>の組から成り、上のレコードでは <CODE>key</CODE>, <CODE>value</CODE>, <CODE>left</CODE>, <CODE>right</CODE> がフィールド名となります(訳注:featureをフィールド名としたのはCTMCP邦訳版にならいました)。対応するフィールドは変数 <CODE>I</CODE>,<CODE>Y</CODE>,<CODE>LT</CODE>, <CODE>RT</CODE> です。レコードの特徴を抜かす事も可能で、その場合には論理プログラミングにおける合成項として知られているものになります。Oz では、これは<EM>タプル(tuple)</EM>と呼ばれます。以下のタプルは同じラベルと上のレコードと同じフィールドを持ちます: </P><BLOCKQUOTE class="code"><CODE>tree(I&nbsp;Y&nbsp;LT&nbsp;RT)</CODE></BLOCKQUOTE><P> </P><P>これはレコードのための構文表記に過ぎません: </P><BLOCKQUOTE class="code"><CODE>tree(1:I&nbsp;2:Y&nbsp;3:LT&nbsp;4:RT)</CODE></BLOCKQUOTE><P> </P><P>ここでフィールド名は <CODE>1</CODE> から始まってタプルの数までの数値です。以下のプログラムは、1つはレコードでもう一つは同じラベルとフィールドを持つタプルから成る2つの要素を表示するものです。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;T&nbsp;I&nbsp;Y&nbsp;LT&nbsp;RT&nbsp;W&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>T&nbsp;=&nbsp;tree(key:I&nbsp;value:Y&nbsp;left:LT&nbsp;right:RT)<BR>I&nbsp;=&nbsp;seif<BR>Y&nbsp;=&nbsp;43<BR>LT&nbsp;=&nbsp;nil<BR>RT&nbsp;=&nbsp;nil<BR>W&nbsp;=&nbsp;tree(I&nbsp;Y&nbsp;LT&nbsp;RT)<BR>{Browse&nbsp;[T&nbsp;W]}</CODE></BLOCKQUOTE><P> </P><P>表示: </P><BLOCKQUOTE class="code"><CODE>[tree(key:seif&nbsp;value:43&nbsp;left:nil&nbsp;right:nil)<BR>&nbsp;tree(seif&nbsp;43&nbsp;nil&nbsp;nil)]</CODE></BLOCKQUOTE><P> </P><H2><A name="label20">3.7レコードの操作</A></H2><P>レコードにおけるいくつかの基本的な操作を論じます。ほとんどの操作はモジュール <A href="../base/record.html#section.records.records"><CODE>Record</CODE></A> で目にする事が出来ます。レコードコンポーネントのフィールドを選択するために、私達は中置のドット演算子を使います。例えば<I>Record</I><CODE><SPAN class="keyword">.</SPAN></CODE><I>Feature</I> </P><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;コンポーネントを選択<BR></SPAN>{Browse&nbsp;T<SPAN class="keyword">.</SPAN>key}<BR>{Browse&nbsp;W<SPAN class="keyword">.</SPAN>1}<BR><SPAN class="comment">%&nbsp;seif が二度 browser に表示されるでしょう<BR></SPAN>seif<BR>seif</CODE></BLOCKQUOTE><P> </P><P>レコードの<EM>引数(arity)</EM>はレコードのフィールド名を辞書順にソートしたものです。レコードの引数を表示するには手続き <CODE>Arity</CODE> を使います。手続き適用 <CODE>{Arity&nbsp;R&nbsp;X}</CODE> は <CODE>R</CODE> がレコードに束縛されると、<CODE>X</CODE> をレコードの引数に束縛します。以下の文を実行すると </P><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;レコードの引数を取得<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Arity&nbsp;T&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Arity&nbsp;W&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>以下を表示するでしょう </P><BLOCKQUOTE class="code"><CODE>[key&nbsp;left&nbsp;right&nbsp;value]<BR>[1&nbsp;2&nbsp;3&nbsp;4]</CODE></BLOCKQUOTE><P> </P><P>他の有用な操作はレコードのフィールドの条件付き選択です。操作 <CODE>CondSelect</CODE> はレコード <CODE>R</CODE>、フィールド名 <CODE>F</CODE>、それとデフォルトのフィールド値 <CODE>D</CODE> を取り、引数 <CODE>X</CODE> を結果として返します。特徴 <CODE>F</CODE> が <CODE>R</CODE> に存在すれば、<CODE>X</CODE> が <CODE>R<SPAN class="keyword">.</SPAN>F</CODE> に束縛され、そうでなければ <CODE>X</CODE> はデフォルトの値 <CODE>D</CODE> に束縛されます。<CODE>CondSelect</CODE> はプリミティブな操作ではありません。それは Oz で定義可能です。以下の文: </P><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;条件によりコンポーネントを選択する<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{CondSelect&nbsp;W&nbsp;key&nbsp;eeva&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{CondSelect&nbsp;T&nbsp;key&nbsp;eeva&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>以下を表示するでしょう </P><BLOCKQUOTE class="code"><CODE>eeva<BR>seif</CODE></BLOCKQUOTE><P> </P><P>Oz で使われる共通の中置のタプル操作演算子は <CODE><SPAN class="keyword">#</SPAN></CODE> です。<CODE>1<SPAN class="keyword">#</SPAN>2</CODE> は2要素のタプルで、<CODE>1<SPAN class="keyword">#</SPAN>2<SPAN class="keyword">#</SPAN>3</CODE> は3要素のタプル: </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">'#'</SPAN>(1&nbsp;2&nbsp;3)</CODE></BLOCKQUOTE><P> </P><P>であって、ペア(pair 2要素タプルのこと) <CODE>1<SPAN class="keyword">#</SPAN>(2<SPAN class="keyword">#</SPAN>3)</CODE> ではありません。<CODE><SPAN class="keyword">#</SPAN></CODE> 演算子では、1要素のタプルを直接書く事は出来ません。代わりに、通常の前置のレコード構文に戻りましょう: 空のタプルは <CODE><SPAN class="string">'#'</SPAN>()</CODE> または <CODE><SPAN class="string">'#'</SPAN></CODE>、そして1要素のタプルは <CODE><SPAN class="string">'#'</SPAN>(X)</CODE> と書かれなくてはいけません。 </P><P>操作 <CODE>{AdjoinAt&nbsp;R1&nbsp;F&nbsp;X&nbsp;R2}</CODE> は <CODE>R2</CODE> を <CODE>R1</CODE> の特徴 <CODE>F</CODE> にフィールド <CODE>X</CODE> を結合した結果と束縛します。<CODE>R1</CODE> が既にフィールド名 <CODE>F</CODE> を持っていれば、結果のレコード <CODE>R2</CODE> は <CODE>R1<SPAN class="keyword">.</SPAN>F</CODE> が <CODE>X</CODE> となっている事を除けば <CODE>R1</CODE> と同じ物です。それ以外では、<CODE>R2</CODE> で返ってくる結果は引数 <CODE>F:X</CODE> が <CODE>R1</CODE> に加えられたものになります。 </P><P>操作 <CODE>{AdjoinList&nbsp;R&nbsp;LP&nbsp;S}</CODE> はフィールド名-フィールドのペアのリストから成るレコード <CODE>R</CODE> を取り、<CODE>S</CODE> で次の様な新しいレコードを返します: </P><UL><LI><P>R のラベルは S のラベルに等しい。</P></LI><LI><P>S は LP で特定されるコンポーネントに加えて LP 中にあるフィールド名を持たない R の全てのコンポーネントを持ちます。</P></LI></UL><P> </P><P>この操作は当然 <CODE>AdjointAt</CODE> を使って定義されます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;S&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{AdjoinList&nbsp;tree(a:1&nbsp;b:2)&nbsp;[a<SPAN class="keyword">#</SPAN>3&nbsp;c<SPAN class="keyword">#</SPAN>4]&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;{Show&nbsp;S}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="comment">%&nbsp;結果は&nbsp;S=tree(a:3&nbsp;b:2&nbsp;c:4)</SPAN></CODE></BLOCKQUOTE><P> </P><H2><A name="label21">3.8リスト(list)</A></H2><P>Scheme や Prolog の様な多くの他の記号的プログラミングでの様に、<EM>list</EM> 形式は Oz におけるデータ構造の重要なクラスです。Oz ではリストのカテゴリは単一のデータ型に属しているわけではありません。それらはむしろ概念的な構造です。リストはアトム <CODE>nil</CODE> によって表現される空のリストか、中置演算子 <CODE><SPAN class="keyword">|</SPAN></CODE> とリストの頭部(head)と尾部(tail)である2つの引数を取るタプルです。それゆえ、最初の3つの正の整数のリストは次の様に表現されます: </P><BLOCKQUOTE class="code"><CODE>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>3<SPAN class="keyword">|</SPAN>nil</CODE></BLOCKQUOTE><P> </P><P>別の便利な特別な表記法は<EM>閉じたリスト(closed list)</EM>です。すなわち決まった要素数のリスト: </P><BLOCKQUOTE class="code"><CODE>[1&nbsp;2&nbsp;3]</CODE></BLOCKQUOTE><P> </P><P>上の表記法は閉じたリストにしか使われず、最初の2要素は <CODE>1</CODE> と <CODE>2</CODE> ですが、その尾部は変数 <CODE>X</CODE> で次の様に見えます: </P><BLOCKQUOTE class="code"><CODE>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>X</CODE></BLOCKQUOTE><P> </P><P>標準的なレコードの表記法をリストのために使う事も出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">'|'</SPAN>(1&nbsp;<SPAN class="string">'|'</SPAN>(2&nbsp;X))</CODE></BLOCKQUOTE><P> </P><P>文字コードに対応した要素のリストにはさらなる表記法の亜種が許されます。この表記法は<EM>文字列(string)</EM>と呼ばれます。例として </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">"OZ&nbsp;3.0"</SPAN></CODE></BLOCKQUOTE><P> </P><P>はリスト </P><BLOCKQUOTE class="code"><CODE>[79&nbsp;90&nbsp;32&nbsp;51&nbsp;46&nbsp;48]</CODE></BLOCKQUOTE><P> </P><P>であり、以下と等しいです。 </P><BLOCKQUOTE class="code"><CODE>[<SPAN class="string">&amp;O</SPAN>&nbsp;<SPAN class="string">&amp;Z</SPAN>&nbsp;<SPAN class="string">&amp;&nbsp;</SPAN>&nbsp;<SPAN class="string">&amp;3</SPAN>&nbsp;<SPAN class="string">&amp;.</SPAN>&nbsp;<SPAN class="string">&amp;0</SPAN>]</CODE></BLOCKQUOTE><P> </P><H2><A name="label22">3.9仮想文字列(virtual string)</A></H2><P>仮想文字列は仮想的な結合(concatenation)をされた文字列として表現される特別なタプルです。その結合は実際に必要になった時に行われます。仮想文字列はファイル、ソケット、ウィンドウによって I/O のために使われます。<CODE>nil</CODE> と <CODE><SPAN class="string">'#'</SPAN></CODE> を除く、数値、文字列、<CODE><SPAN class="string">'#'</SPAN></CODE>でラベル付けられたタプルの様な全てのアトムは仮想文字列を構成出来ます。ここに一例を示します: </P><BLOCKQUOTE class="code"><CODE>123<SPAN class="keyword">#</SPAN><SPAN class="string">"-"</SPAN><SPAN class="keyword">#</SPAN>23<SPAN class="keyword">#</SPAN><SPAN class="string">"&nbsp;is&nbsp;"</SPAN><SPAN class="keyword">#</SPAN>100</CODE></BLOCKQUOTE><P> </P><P>これは下の文字列を表現します </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">"123-23&nbsp;is&nbsp;100"</SPAN></CODE></BLOCKQUOTE><P> </P><P class="warning"><STRONG>注意:</STRONG>このセクションで論じた各データ型は、Mozart システムのモジュールに対応しています。それらのモジュールはデータ型に対応した操作を定義しています。あなたはより多くのこれらの操作に関する事を <A href="../base/index.html">The Oz Base Environment documentation</A> で見る事が出来ます。 </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.opi">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.equality">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
