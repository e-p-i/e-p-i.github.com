<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>9 Stateful Data Types</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#chapter.concurrency">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node10.html#chapter.classes">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.stateful"><H1><A name="chapter.stateful">9 Stateful Data Types</A></H1><P>Oz はステートフル(訳注:状態を持つ、代入可能とほぼ同義です)なデータ型を提供しています。これらはポート(port)、オブジェクト(object)、配列(array)、辞書(dictionary)(ハッシュテーブル(hash table))を含みます。これらのデータ型は、型のメンバーについて行われる操作の集合によってのみ特徴付けられる意味で、抽象です。それらの実装は常に隠蔽されており、実際には異なる実装が存在しますが、その対応する振る舞いは同じです。例えば、オブジェクトはコンパイラの最適化レベルに依存して完全に異なる方法で実装されています。それぞれのメンバーは、生成時の Oz-name によって概念的にタグ付けされた常にユニークなものです。メンバーは明示的な生成操作で生成されます。型テスト操作が常に存在します。加えて、メンバーはアクセス不可能になると消滅します。 </P><DIV id="section.stateful.port"><H2><A name="section.stateful.port">9.1ポート(port)</A></H2><P>ポートは抽象データ型の様な物です。ポート <CODE>P</CODE> はいくつかの送信者間で共有出来る非同期なコミュニケーションチャネルです。ポートは関連付けられたストリームを持っています。操作: <CODE>{Port<SPAN class="keyword">.</SPAN>new&nbsp;S&nbsp;?P}</CODE> はポート <CODE>P</CODE> を作り、ストリームの役割を担う変数 <CODE>S</CODE> に接続するよう初期化されます。操作: <CODE>{Port<SPAN class="keyword">.</SPAN>send&nbsp;P&nbsp;M}</CODE> はメッセージ <CODE>M</CODE> を <CODE>P</CODE> に関連付けられたストリームの末端に追加します。ポートは次の挿入点としてストリームの末端を指し続けます。操作 <CODE>{IsPort&nbsp;P&nbsp;?B}</CODE> は <CODE>P</CODE> がポートかどうかをチェックします。ストリーム <CODE>S</CODE> を誤って束縛するのを防ぐため、<CODE>S</CODE> は実際にはフューチャです。以下のプログラムはポートの簡単な例を示しています: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;S&nbsp;P<BR>P&nbsp;=&nbsp;{Port<SPAN class="keyword">.</SPAN>new&nbsp;S}<BR>{Browse&nbsp;S}&nbsp;</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{Port<SPAN class="keyword">.</SPAN>send&nbsp;P&nbsp;1}<BR>{Port<SPAN class="keyword">.</SPAN>send&nbsp;P&nbsp;2}</CODE></BLOCKQUOTE><P> </P><P>あなたが上の文を漸増的に入力する時、<CODE>S</CODE> が漸増的に定義されていくのが観察できるでしょう。 </P><BLOCKQUOTE class="code"><CODE>S<BR>1<SPAN class="keyword">|</SPAN>&nbsp;<BR>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> </P><P>ポートは <A href="node8.html#section.concurrency.stream">Section&nbsp;8.2</A> で論じられた純粋なストリームコミュニケーションよりも表現力の高い抽象です、なぜならポートは複数のスレッド間で共有でき、他のデータ構造に組み込めるからです。Oz ではポートはスレッド間の主要なメッセージパッシング機構です。 </P></DIV><DIV id="section.stateful.clientserver"><H2><A name="section.stateful.clientserver">9.2クライアント-サーバ コミュニケーション</A></H2><P>ポートはサーバへのコミュニケーションのエントリポイントとして使われます。<A href="node9.html#concurrentqueue">Figure&nbsp;9.1</A> に示されるプログラムはFIFOキューサーバの役割を行うスレッドを定義します。それは2つのポートを持っています、一つはアイテムを <CODE>put</CODE> を使って挿入するもの、他方はアイテムを <CODE>get</CODE> を使ってキューから取得するものです。単一代入(論理)変数の利用は、サーバを <CODE>get</CODE> と <CODE>put</CODE> 要求の順序に対して繊細ではなくします。<CODE>get</CODE> 要求はキューが空でも到着します。サーバは <CODE>{NewQueueServer&nbsp;?Q}</CODE> によって生成されます。この手続きはレコード <CODE>Q</CODE> を1引数の手続きを持つフィールド名(feature) <CODE>put</CODE> と <CODE>get</CODE> と一緒に返します。<CODE>Q</CODE> へのアクセスを持っているクライアントスレッドはこれらの手続きを呼び出してサービスを要求できます。結果は論理変数を通してどの様に返っているかに注目して下さい。クライアントによるキュー中のアイテムの要求は <CODE>{Q<SPAN class="keyword">.</SPAN>get&nbsp;I}</CODE> を呼び出す事です。サーバは最終的に <CODE>I</CODE> をアイテムに束縛して回答します。 </P><P></P><DIV class="figure" id="concurrentqueue"><HR><P><A name="concurrentqueue"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewQueueServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;GivePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Given}<BR>&nbsp;&nbsp;&nbsp;Taken&nbsp;TakePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Taken}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;=&nbsp;Taken<BR>&nbsp;&nbsp;&nbsp;queue(put:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;GivePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;TakePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.1:</STRONG> 並行キューサーバ、初版 </P><HR></DIV><P> </P><P>以下の文のシーケンスを試しましょう。このプログラムはうまく動かないでしょう。何が問題なのでしょうか？ </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">thread</SPAN>&nbsp;Q&nbsp;=&nbsp;{NewQueueServer}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>{Q<SPAN class="keyword">.</SPAN>put&nbsp;1}<BR>{Browse&nbsp;{Q<SPAN class="keyword">.</SPAN>get&nbsp;$}}<BR>{Browse&nbsp;{Q<SPAN class="keyword">.</SPAN>get&nbsp;$}}<BR>{Browse&nbsp;{Q<SPAN class="keyword">.</SPAN>get&nbsp;$}}<BR>{Q<SPAN class="keyword">.</SPAN>put&nbsp;2}<BR>{Q<SPAN class="keyword">.</SPAN>put&nbsp;3}</CODE></BLOCKQUOTE><P> </P><P> 問題は <CODE>Given&nbsp;=&nbsp;Taken</CODE> が2つのフューチャ間に同等性を課そうとしている事です。<CODE>Given</CODE> と <CODE>Taken</CODE> は読み取り専用で束縛できないフューチャである事を思い出して下さい。それで、キューサーバに対応付けられたスレッドは文 <CODE>Given&nbsp;=&nbsp;Taken</CODE> で一時停止します。この問題はこの文を <A href="node9.html#concurrentqueue1">Figure&nbsp;9.2</A> に見られるように自身のスレッドで走らせる事で対応出来ます。<A href="node9.html#label52"><SUP>1</SUP></A> </P><P> 問題は以下の様に働きます。<CODE>{Q<SPAN class="keyword">.</SPAN>put&nbsp;I0}&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;I1}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;In}</CODE> は要素 <CODE>I0&nbsp;I1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;In</CODE> をストリーム <CODE>Given</CODE> に漸増的に追加し、<CODE>I0<SPAN class="keyword">|</SPAN>I1<SPAN class="keyword">|...|</SPAN>In<SPAN class="keyword">|&lt;</SPAN>Future1<SPAN class="keyword">&gt;</SPAN></CODE> として返ってきます。<CODE>{Q<SPAN class="keyword">.</SPAN>get&nbsp;X0}&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;X1}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;Xn}</CODE> は要素 <CODE>X0&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn</CODE> をストリーム <CODE>Taken</CODE> に漸増的に追加し、<CODE>X0<SPAN class="keyword">|</SPAN>X1<SPAN class="keyword">|...|</SPAN>Xn<SPAN class="keyword">|&lt;</SPAN>Future2<SPAN class="keyword">&gt;</SPAN></CODE> として返ってきます。同等性制約 <CODE>Given&nbsp;=&nbsp;Taken</CODE> は <CODE>Xi<SPAN class="string">'s</SPAN></CODE> を <CODE>Ii<SPAN class="string">'s</SPAN></CODE> に束縛するでしょう。 </P><P></P><DIV class="figure" id="concurrentqueue1"><HR><P><A name="concurrentqueue1"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewQueueServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;GivePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Given}<BR>&nbsp;&nbsp;&nbsp;Taken&nbsp;TakePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Taken}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;Given=Taken&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;queue(put:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;GivePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;TakePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.2:</STRONG> 並行キューサーバ</P><HR></DIV><P></P><P class="warning"><STRONG>注意:</STRONG> 上のコードは正しいですが、現在の Oz の実装に限定され、メモリリークを起こします。回避策として、下のコードをとりあえずの代替として使えます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewQueueServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;GivePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Given}<BR>&nbsp;&nbsp;&nbsp;Taken&nbsp;TakePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Taken}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">for</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Given&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Taken&nbsp;<SPAN class="keyword">do</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X=Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;queue(put:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;GivePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;TakePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P class="warning"> </P></DIV><DIV id="section.stateful.chunk"><H2><A name="section.stateful.chunk">9.3チャンク(chunk)</A></H2><P>ポートは実際にはステートフルなデータ構造です。ポートは対応するストリームの末端を指す事によって内部的にローカルな状態を保持しています。Oz は抽象的でステートフルなデータ型を構築するために2つのプリミティブな装置<EM>チャンク(chunk)</EM>と<EM>セル(cell)</EM>を持っています。全ての他のチャンクのサブ型はチャンクとセルの項で定義出来ます。 </P><P>チャンクはラベルが oz-name である事、引数を取る操作が無い事以外はレコードに似ています。これは、チャンクにおいて、コンポーネントのフィールド名(feature)がユーザー定義の操作に対してのみレキシカルスコープで可視なoz-nameである時、チャンクの特定のコンポーネントを隠す事が出来る事を意味します。 </P><P>チャンクは手続き <CODE>{NewChunk&nbsp;Record}</CODE> によって作られます。これはチャンクをユニークなラベルを持つレコードと同じコンポーネントとして生成します。以下のプログラムはチャンクを生成します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X={NewChunk&nbsp;f(c:3&nbsp;a:1&nbsp;b:2)}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X<SPAN class="keyword">.</SPAN>c}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>これは以下を表示するでしょう。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">&lt;</SPAN>Ch<SPAN class="keyword">&gt;</SPAN>(a:1&nbsp;b:2&nbsp;c:3)<BR>3</CODE></BLOCKQUOTE><P></P><P class="warning"><STRONG>注意:</STRONG> 構文的便宜として、式 <CODE>E</CODE> を <CODE>X&nbsp;=&nbsp;E</CODE> として変数と同じものにして <CODE>X</CODE> を使えば式の値を参照出来ます。上のプログラムはこの記法を用いて次の様に書き直せます </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X={NewChunk&nbsp;f(c:3&nbsp;a:1&nbsp;b:2)}}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X<SPAN class="keyword">.</SPAN>c}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P class="warning"> </P><P><A href="node9.html#portcellchunk">Figure&nbsp;9.3</A> で、ポートを実装するのにチャンクの情報隠蔽の能力の使用例を示します。 </P></DIV><DIV id="section.stateful.cell"><H2><A name="section.stateful.cell">9.4セル(cell)</A></H2><P>セルは代入可能な一つのコンポーネントを持つチャンクの様に見えます。セルは以下の様に生成されます。 </P><BLOCKQUOTE class="code"><CODE>{NewCell&nbsp;X&nbsp;?C}</CODE></BLOCKQUOTE><P> </P><P>セルは初期内容 <CODE>X</CODE> と一緒に作られます。<CODE>C</CODE> がセルと束縛されています。<A href="node9.html#cellop">Table&nbsp;9.1</A> はセルについての操作を示しています。 </P><P></P><DIV class="table" id="cellop"><HR><P><A name="cellop"></A></P></DIV><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>操作</P></TH><TH><P>記述</P></TH></TR><TR valign="top"><TD><P><CODE>{NewCell&nbsp;X&nbsp;?C}</CODE></P></TD><TD><P>セル C を内容 X で生成する</P></TD></TR><TR valign="top"><TD><P><CODE>X=<SPAN class="keyword">@</SPAN>C</CODE></P></TD><TD><P>C の内容を X に返す</P></TD></TR><TR valign="top"><TD><P><CODE>C<SPAN class="keyword">:=</SPAN>Y</CODE></P></TD><TD><P>C の内容を Y に修正する</P></TD></TR><TR valign="top"><TD><P><CODE>{IsCell&nbsp;<SPAN class="keyword">+</SPAN>C}</CODE></P></TD><TD><P>C がセルかどうかのテスト</P></TD></TR><TR valign="top"><TD><P><CODE>{Exchange&nbsp;<SPAN class="keyword">+</SPAN>C&nbsp;X&nbsp;Y}</CODE></P></TD><TD><P>C の内容を X から Y にアトミックに交換する</P></TD></TR></TABLE><DIV class="table"><P class="caption"><STRONG>Table&nbsp;9.1:</STRONG> セルの操作</P><HR></DIV><P> </P><P>以下のプログラムをチェックして下さい。最後の文はセルを1増加させています。<CODE><SPAN class="keyword">thread</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> を出るとプログラムはデッドロックします。何故か分かりますか？ </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;I&nbsp;O&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;{NewCell&nbsp;a}&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR>&nbsp;&nbsp;&nbsp;{Assign&nbsp;I&nbsp;b}&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR>&nbsp;&nbsp;&nbsp;{Assign&nbsp;I&nbsp;X}&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5<SPAN class="keyword">*</SPAN>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Exchange&nbsp;I&nbsp;O&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;O<SPAN class="keyword">+</SPAN>1&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>セルと高階反復子(higher-order iterator)は便利な代入ベースのプログラミングを Oz で可能にします。以下のプログラムはセル <CODE>J</CODE> に <IMG alt="\sum_{i=1}^10 i" src="latex2.png"> の値を累算(accumulate)しています。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;J&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>J&nbsp;=&nbsp;{NewCell&nbsp;0}<BR>{For&nbsp;1&nbsp;10&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O&nbsp;N&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;J&nbsp;O&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;=&nbsp;O<SPAN class="keyword">+</SPAN>I<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>{Browse&nbsp;<SPAN class="keyword">@</SPAN>J}</CODE></BLOCKQUOTE><P> </P><P><A href="node9.html#section.stateful.port">Section&nbsp;9.1</A> で記述されるポートは、チャンクとセルの仕様により安全な方法で実装できます、つまり偽造出来ない抽象データ型としてです。<A href="node9.html#portcellchunk">Figure&nbsp;9.3</A> に見るプログラムはポートの実装です。最初 Oz-name はローカルに作られ、それは Port 操作によってのみアクセス出来ます。ポートはチャンクとして作られ、一つのコンポーネントのセルを持っています。セルはポートに関連付けられたストリームに初期化されています。型テスト <CODE>IsPort</CODE> はフィールド名 <CODE>Port</CODE> のチェックによって行われます。メッセージをポートに送ると、ストリームが自動的に更新され、セルはストリームの尾部を指すよう更新されます。 </P><P></P><DIV class="figure" id="portcellchunk"><HR><P><A name="portcellchunk"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Port&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;PortTag&nbsp;=&nbsp;{NewName}&nbsp;<SPAN class="comment">%新しい Oz name<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewPort</SPAN>&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;{NewCell&nbsp;S}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NewChunk&nbsp;port(PortTag:C)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IsPort</SPAN>&nbsp;?P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Chunk<SPAN class="keyword">.</SPAN>hasFeature&nbsp;P&nbsp;PortTag}&nbsp;<SPAN class="comment">%チャンクの特徴のチェック<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Send</SPAN>&nbsp;P&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;Mr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;P<SPAN class="keyword">.</SPAN>PortTag&nbsp;Ms&nbsp;Mr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;=&nbsp;M<SPAN class="keyword">|</SPAN>Mr<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;Port&nbsp;=&nbsp;port(new:NewPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is:IsPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send:Send)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.3:</STRONG> セルとチャンクによるポートの実装</P><HR></DIV><P></P><P> <A href="node9.html#portcellchunk">Figure&nbsp;9.3</A> での実装はポートのストリームを保護しません。ストリームの保護は以下の様にフューチャを使って行われます。 </P><P></P><DIV class="figure" id="portcellchunkf"><HR><P><A name="portcellchunkf"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Port&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;PortTag&nbsp;=&nbsp;{NewName}&nbsp;<SPAN class="comment">%新しい Oz name<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewPort</SPAN>&nbsp;FS}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;C&nbsp;=&nbsp;{NewCell&nbsp;S}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FS&nbsp;=&nbsp;<SPAN class="keyword">!!</SPAN>S&nbsp;&nbsp;<SPAN class="comment">%&nbsp;&nbsp;フューチャを生成する<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NewChunk&nbsp;port(PortTag:C)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IsPort</SPAN>&nbsp;?P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Chunk<SPAN class="keyword">.</SPAN>hasFeature&nbsp;P&nbsp;PortTag}&nbsp;<SPAN class="comment">% チャンクのフューチャをチェックする<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Send</SPAN>&nbsp;P&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;Mr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;P<SPAN class="keyword">.</SPAN>PortTag&nbsp;Ms&nbsp;Mr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;=&nbsp;M<SPAN class="keyword">|!!</SPAN>Mr<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;Port&nbsp;=&nbsp;port(new:NewPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is:IsPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send:Send)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.4:</STRONG> セルとチャンクによってポートを実装する</P><HR></DIV><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#chapter.concurrency">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node10.html#chapter.classes">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label52">1. </A>このFIFOキューサーバのデザインは Denys Duchier によって提案されたものです</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
