<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>2 The Interactive Development Environment</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.opi"><H1><A name="chapter.opi">2 The Interactive Development Environment</A></H1><H3 class="authors"><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A> and&nbsp;<A href="http://www.sics.se/~andreas">Andreas&nbsp;Sundstr�m</A></H3><P>このチュートリアルは多くのコードの例を含み、進むとともにそれらを対話的に試してみる事が強く推奨されます。これは Mozart システムの対話開発環境を活用する事によりとても快適に行う事が出来ます。私達は普通それを OPI <EM>Oz Programming Interface</EM> と呼び、それは <A href="../opi/index.html">``The Oz Programming Interface''</A> に広範に記述されています。このセクションでは、私達のコードの例を試す事を始められるのに過不足無い量の OPI についての学習をします。</P><H2><A name="label7">2.1OPI を始める</A></H2><P>Unix環境では、OPI はコマンド <CODE>oz</CODE> をシェルプロンプトから実行する事で開始します。Windows環境では、インストール後に提供しているであろう Mozart システムプログラムグループから Mozart を選んでクリックして下さい。この様なウィンドウを目にすることになるでしょう。 </P><DIV align="center"><IMG alt="" src="opi1.gif"></DIV><P> OPI はプログラミングのフロントエンドとして Emacs エディタを使っています。あなたが Emacs やその用語に親しんでいなければ、Emacs メニューバーのヘルプメニューからEmacs のオンラインチュートリアル <A href="bib.html#stallman91">[Sta91]</A> を引いてみるといいでしょう。</P><P>開始直後のウィンドウは2つのテキストバッファに分かれています。<CODE>Oz</CODE> と呼ばれる上のバッファはあなたがコードの小片を書いて対話的に実行を行える場所です。それは Oz コードにとって、emacs lisp コードにとっての <CODE><SPAN class="keyword">*</SPAN>scratch<SPAN class="keyword">*</SPAN></CODE> バッファと同じ役割を演じます。下のバッファは　<CODE><SPAN class="keyword">*</SPAN>Oz&nbsp;Compiler<SPAN class="keyword">*</SPAN></CODE> と呼ばれ、あなたの話を Mozart サブプロセスのコンパイラによって変換した結果を表示します。 </P><H2><A name="label8">2.2 Hello World</A></H2><P>伝統的な <EM>Hello World</EM> の例から始めましょう。<CODE>Oz</CODE> バッファの中に以下をタイプして下さい: </P><BLOCKQUOTE class="code"><CODE>{Show&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}</CODE></BLOCKQUOTE><P> この例は Oz が手続きを呼び出す一風変わった構文を示しています。: それは {}(curly braces) によって指示されます。ここでは、手続き <CODE>Show</CODE> がアトム(atom) <CODE><SPAN class="string">'Hello&nbsp;World'</SPAN></CODE> という1つの引数で呼び出されています。</P><P>この小片を実行するため、タイプした行にカーソルを合わせ、メニューバーの Oz メニューから <EM>Feed Line</EM> を選択しましょう。このようになるでしょう: </P><DIV align="center"><IMG alt="" src="opi2.gif"></DIV><P> コンパイラからの変換は <CODE>{Show&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}</CODE> を餌(<EM>fed</EM>)としてコンパイラに与えた結果として <EM>accepted</EM> の様になっていれば、正しく構文解析されてコンパイルされています。実行はされましたが、そうだとして、出力はどこでしょう？確かに実行はされているのですが、出力は <CODE><SPAN class="keyword">*</SPAN>Oz&nbsp;Emulator<SPAN class="keyword">*</SPAN></CODE> と呼ばれる別のバッファに表れます。:これは実行結果を含みます。Oz メニューから <EM>Show/Hide -&gt; Emulator</EM> を選べば、このようになるでしょう: </P><DIV align="center"><IMG alt="" src="opi3.gif"></DIV><P></P><H2><A name="label9">2.3プログラマへの良いニュース</A></H2><P>OPI は対話的コード開発をサポートする多くの特徴を持っています。 </P><H3><A name="label10">2.3.1コード編集</A></H3><P><CODE>oz-mode</CODE> は Oz のコードを編集するための主要なモードで、自動インデントだけでなくコードの色付けのための <CODE>font-lock</CODE> をサポートします。</P><H3><A name="label11">2.3.2キーバインド</A></H3><P>前に示した <CODE>Oz</CODE> バッファからだけでなく、<CODE>oz-mode</CODE> のどのバッファからでも Mozart サブプロセスと対話が出来ます。さらには、<EM>Hello World</EM> の例で実行した全ての動作は Oz メニューからの代わりにキーバインドからより便利に呼び出せます。 </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TD><P><SPAN class="key">C-. C-l</SPAN></P></TD><TD><P>現在の行をフィード(Ozに命令を取り込ませる)</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. C-r</SPAN></P></TD><TD><P>選択した部分をフィード</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. C-b</SPAN></P></TD><TD><P>全バッファをフィード</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">M-C-x</SPAN></P></TD><TD><P>現在の段落(paragraph)をフィード</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. C-p</SPAN></P></TD><TD><P><EM>同上</EM></P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. c</SPAN></P></TD><TD><P>
<CODE>*Oz&nbsp;Compiler*</CODE> バッファの表示on/off切り替え</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. e</SPAN></P></TD><TD><P>
<CODE>*Oz&nbsp;Emulator*</CODE> バッファの表示on/off切り替え</P></TD></TR></TABLE><P> 段落(paragraph)とは空白行で区切られた記述部分の事です。 </P><H3><A name="label12">2.3.3コンパイルエラー</A></H3><P>OPI はコンパイラによって報告されたエラーの便利な引用もサポートしています。<CODE>Oz</CODE> バッファに以下の様なエラー含みのコードをタイプしてみましょう: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;A&nbsp;B&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;3<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">B</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Show&nbsp;A&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;<SPAN class="string">'Tinman'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{B&nbsp;7}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> そして <SPAN class="key">M-C-x</SPAN> を使ってコンパイラにフィードしましょう。コンパイラは2つのエラーを報告し、私達はそれらを見る事になります: </P><DIV align="center"><IMG alt="" src="opi4.gif"></DIV><P> <SPAN class="key">C-x `</SPAN> (<EM>Control-x backquote</EM>)は、最初のエラーメッセージを見えるようにしてソースバッファ中でバグが存在しているとされる場所にポインタを位置させます。 </P><DIV align="center"><IMG alt="" src="opi5.gif"></DIV><P> 確かに、整数とアトムを加算すべきではありません！<SPAN class="key">C-x `</SPAN> をもう一度呼び出すと: </P><DIV align="center"><IMG alt="" src="opi6.gif"></DIV><P> この様に、私達は誤って引数を取らない手続き(nullary procedure)を実引数(argument)に適用しています。 </P><H3><A name="label13">2.3.4グラフィカルな開発ツール</A></H3><P>Mozart システムは多くのグラフィカルなツールを持っています。ここでは <EM>Browser</EM> のみに言及しましょう。これは <A href="../browser/index.html">``The Oz Browser''</A> 中に広く記述されています。これまで、手続き <CODE>Show</CODE> を単に値を表示するために使っていました。その代わりに、<CODE>Browse</CODE> を使ってグラフィカルな表示インターフェースを得られます。例として、以下をフィードしましょう: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}</CODE></BLOCKQUOTE><P> 以下の新しいウィンドウのポップアップを引き起こします: </P><DIV align="center"><IMG alt="" src="opi7.gif"></DIV><P> あまり面白くないですね、しかしこのコードをフィードしてみましょう: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;W&nbsp;H<BR>{Browse&nbsp;foo(width:W&nbsp;height:H&nbsp;surface:<SPAN class="keyword">thread</SPAN>&nbsp;W<SPAN class="keyword">*</SPAN>H&nbsp;<SPAN class="keyword">end</SPAN>)}</CODE></BLOCKQUOTE><P> 今度は browser ウィンドウは部分的に知識が得られている(初期化されている)項のみを表示します(なぜなら <CODE>W</CODE> と <CODE>H</CODE> は宣言されているものの値に束縛されていないので): </P><DIV align="center"><IMG alt="" src="opi8.gif"></DIV><P> ここで <CODE>W=3</CODE> をフィードしてみると、browser が私達が今まさに加えた情報を反映させるために自動的に表示を更新します。 </P><DIV align="center"><IMG alt="" src="opi9.gif"></DIV><P> <CODE>H=5</CODE> をフィードすると再び browser は更新し全て具体化された項を表示します: </P><DIV align="center"><IMG alt="" src="opi10.gif"></DIV><P> browser は並行計算(スレッド)の進行に伴う項の具体化(instantiation)の進化に加えてより多くの情報を見る事を可能にします。 </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
