<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>12 Logic Programming</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node11.html#chapter.objectscc">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="bib.html#label86">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.lp"><H1><A name="chapter.lp">12 Logic Programming</A></H1><P>多くの問題、特に人工知能(Artificial Intelligence)の領域で頻度の高いものは、他の場所でも見られます、例えば、オペレーションズリサーチは現在のところいくつかの探索と<EM>制約(constraint)</EM>の伝播(propagation)の形式によってのみ解決可能です(訳注:NP問題やSATソルバ等のキーワードで調べるといいかもしれません)。もしプログラミング言語が don't know 非決定性(nondeterminism)を提供する事により探索の詳細を抽象して排除するのであれば、そのような問題は正に適切に特定されます。論理プログラミングと Prolog はこの種の問題のために適した形式主義と考えられます。このチャプタでは私達は Oz での論理プログラミングと並行制約プログラミングの表し方について話します。論理プログラミングでは各手続きは論理文によって表現された関係として翻訳されます。私達は Oz と Prolog の間の関係と、いかに多くの Prolog プログラムが Oz プログラムに直接的に変換できるかについて話します。より進んだ制約解決技法のために、読者には Oz での制約プログラミングについての随伴チュートリアルに見えるかもしれません。 </P><P class="warning"><STRONG>注意:</STRONG>このチャプタの内容はまだ不完全である事に注意して下さい。(訳注:というわけで訳も中途半端です。本家の文書化が終わってから見直したいと思います。) </P><H2><A name="label64">12.1制約ストア(constraint store)</A></H2><P>Oz のスレッドは変数の束縛が同等性形式で保存されるストアを共有しています: <IMG alt="X_1=U_1, \ldots, X_n=U_n" src="latex3.png"> ここで <IMG alt="X_i" src="latex4.png"> は変数で <IMG alt="U_i" src="latex5.png"> は Oz のエンティティか変数です。制約ストアは、レコード、数、変数の名前、手続きを識別するユニークな名前、セル、チャンクの種々の型(クラス、オブジェクト、フューチャ、etc)に対応する Oz の値を含んでいます。概念的に、ストアは連言論理式(conjunctive logical formula)としてモデル化されます: <IMG alt="\exists Y_1 \ldots Y_m : X_1=U_1 \wedge \ldots \wedge X_n=U_n" src="latex6.png"> ここで <IMG alt="X_i" src="latex4.png"> は変数で <IMG alt="U_i" src="latex5.png"> は Oz の値か変数で、<IMG alt="Y_i " src="latex7.png"> は <IMG alt="X_i " src="latex4.png"> と <IMG alt="U_i " src="latex5.png"> で発生した変数の和です。ストアは<EM>制約ストア(constraint store)</EM>と呼ばれます。Oz の <EM>計算ストア(computation store)</EM>は制約ストア、手続きが位置している手続きストア、そしてセルとオブジェクト状態が位置しているセルストアから構成されています。 </P><H2><A name="label65">12.2計算空間(computation space)</A></H2><P>計算空間は一般的に計算ストアと実行中のスレッドの集合から構成されています。これまで私達が見てきたのは単一の計算空間です。論理プログラミングを扱う時、複数のネストした計算空間によってより凝った構造が現れるでしょう。計算空間の構造のための一般的なルールは以下のようになります。 </P><UL><LI><P>そこには常に外部の世界とやりとりを行うスレッドがある最上位の計算空間が存在します。スレッドが最上位の空間のストアに充足しない(inconsistent)制約(束縛)を追加しようとすると、スレッドから失敗例外が発生します。充足しない制約の追加はアボートされ、制約ストアは常に充足した状態を保つでしょう。 </P></LI><LI><P>スレッドは直接的または間接的にこのセクションで示されるようなローカルの計算空間を生成出来ます。新しい計算空間は子空間になり現在の計算空間は親空間になります。一般的に計算空間の階層が作られ得ます。 </P></LI><LI><P>スレッドは常に一つの計算空間に所属しています。また、変数は一つの計算空間にのみ所属しています。 </P></LI><LI><P>子空間のスレッドは、その空間と同様に全ての祖先の空間の変数を見る事が出来、またアクセス出来るかもしれません。逆は偽です。親空間のスレッドは、子空間が親空間に併合されない限り、子空間の変数を見る事が出来ません。その様な場合、子空間は消え去り、その内容全ては親空間に追加されます。空間の併合操作は明示的な操作、またはこのセクションで見る事になる非直接的な言語制約によって発生します。 </P></LI><LI><P>子空間のスレッドはそれに可視な変数に制約(束縛)を追加します。これはその空間か祖先の空間に所属する変数を束縛出来るという事を意味します。束縛は現在の空間とその子孫空間でのみ可視です。 </P></LI></UL><P> </P><H2><A name="label66">12.3制約の含意(entailment)と非含意(disentailment)</A></H2><P>状態(condition) <IMG alt="C" src="latex8.png"> は <IMG alt="C" src="latex8.png"> の場合に <IMG alt="\sigma" src="latex9.png"> でストアされ、論理式として考えられ、論理的にストア <IMG alt="\sigma" src="latex9.png"> に含まれ、再び論理式として考えられます。<IMG alt="C" src="latex8.png"> の直観的含意は <IMG alt="C" src="latex8.png"> を既にそこにある情報を増加させないストアに追加する事を意味します。全ては既にそこにあります。 </P><P>状態 <IMG alt="C" src="latex8.png"> は <IMG alt="\sigma" src="latex9.png"> によって論理的に含まれる <IMG alt="C" src="latex8.png"> が否定(negation)の場合は非含意されます。非含意制約はストアに既にある情報によって非充足となります。 </P><P> 制約ストアは論理式であるので、私達は含意されている制約ストアもしくは他の制約ストアによって非含意されている制約ストアについて語る事が出来ます。空間 <IMG alt="S_0" src="latex10.png"> は <IMG alt="S_1" src="latex11.png"> が成立する場合、制約ストアによって <IMG alt="S_0" src="latex10.png"> が含意(非含意)される場合、他の空間 <IMG alt="S_1" src="latex11.png"> により含意(非含意)されます。 </P><P> 私達は非含意される(普通親空間によって)空間を<EM>失敗した空間(failed space)</EM>と呼びます。 </P><H3><A name="label67">12.3.1例</A></H3><P>ストア <IMG alt="\sigma \equiv X = 1 \wedge \ldots \wedge Y = f(X \ Z)" src="latex12.png"> と以下の状態について考えて下さい: </P><UL><LI><P><IMG alt="X=1" src="latex13.png"> これは、この束縛は情報ストアを増加させないので、含意されます。 </P></LI><LI><P><IMG alt="\exists U : Y=f(1 \ U)" src="latex14.png"> これも含意されます。この情報を追加する事は私達の情報を増加させません。上の状態を充たす <IMG alt="Z" src="latex15.png"> があります。私達は <IMG alt="Z" src="latex15.png"> がどんな値を仮定しているか知らない事に注意して下さい。しかしどの値が <IMG alt="Z" src="latex15.png"> によって仮定されても、状態は依然として充たされています。 </P></LI><LI><P><IMG alt="Y=f(1 \ 2)" src="latex16.png"> はストアによって含意されません、なぜならこの等価性の追加は <IMG alt="Z=2" src="latex17.png"> を作る事によって情報ストアを増加させるからです。 </P></LI><LI><P><IMG alt="X=2" src="latex18.png"> つまり <IMG alt="Y=f(3 \ U)" src="latex19.png"> は両方非含意となります、なぜならそれらは既に現れている情報と反するからです。これらは失敗例外を発生させるでしょう: この最上位の空間は普通ユーザにエラーメッセージを報告し、ここで劣位の空間は単に失敗します。 </P></LI></UL><P> </P><H2><A name="label68">12.4選言(disjunction)</A></H2><P>今私達は Oz の非決定的構築を理解する位置にいます。Oz は<EM>非決定的選択(nondeterminate choice)</EM>のためにいくつかの選言的構築を提供しており、それは <EM>don't know choice</EM> 文としても知られています。 </P><H3><A name="label69">12.4.1 or 文</A></H3><P>私達が使おうとしている全ての選言の文は、節(clause)とガード(guard)の記法です。節はガード <I>G</I> と本体 <I>S1</I> から構成され、以下の形式を持っています: </P><BLOCKQUOTE class="code"><I>G</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I></BLOCKQUOTE><P> </P><P> ガード <I>G</I> は次の形式を持っています: </P><BLOCKQUOTE class="code"><CODE>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Xn</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I><CODE>&nbsp;</CODE></BLOCKQUOTE><P> ここで変数 <I>Xi</I> は、スコープをガード部と本体部の両方に広げる事によって、実存的に定量化されます。 </P><P>最初の選言の文は以下の形式を持っています: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">or</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>G1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>G2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>GN</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>SN</I><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE><SPAN class="keyword">or</SPAN></CODE> 文は以下の意味論を持っています。スレッドは空間 <I>SP</I> の文を実行していると仮定する。 </P><UL><LI><P>スレッドはブロックされる。 </P></LI><LI><P><IMG alt="N" src="latex20.png"> 空間はガードを実行する新しいスレッド<IMG alt="SP_1, \ldots, SP_N" src="latex21.png">によって(with)<IMG alt="N" src="latex20.png">生成されます。 </P></LI><LI><P>父スレッドの実行は子空間の最大一つが失敗せずに帰ってくるまでブロックされたままです。 </P></LI><LI><P>もし全ての子空間が失敗した場合、親スレッドはその空間の失敗状態をあげます。これは親スレッドの空間が最上位の空間であった場合、失敗例外が発生する事を意味します。それ以外の場合では、空間はローカルで、失敗した空間となります。 </P></LI><LI><P>ただ一つの空間が対応する節<IMG alt="G_i" src="latex23.png"> <CODE><SPAN class="keyword">then</SPAN></CODE> <IMG alt="S_i" src="latex24.png"> が失敗しないまま残ります。<IMG alt="G_i" src="latex23.png"> がゴール(goal) <IMG alt="G'_i" src="latex25.png"> と制約 <IMG alt="\theta" src="latex26.png"> に減らされるとも仮定して下さい。この場合、空間は親空間に併合されます。<IMG alt="\theta" src="latex26.png"> とストアの変数は親空間のストアに追加されます。<IMG alt="G'_i" src="latex25.png"> は自身のスレッドで実行し、元々の一時停止しているスレッドは文 <IMG alt="S_i" src="latex24.png"> の実行を再開します。この実行のルールは Oz で <EM>unit commit</EM> と呼ばれます、なぜなら実行が単一の代替の選言(唯一残ったもの)をコミットするからです。 </P></LI></UL><P> </P><H3><A name="label70">12.4.2短縮記法</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">or</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Gi</I><CODE>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>は次を意味します </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">or</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Gi</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P> <CODE><SPAN class="keyword">or</SPAN></CODE> 文はどんな don't know 非決定性も導入しない事を観察して下さい。この様な文の実行はアクションの確定コース(determinate course)で働くまで待機します。 </P><H3><A name="label71">12.4.3Prolog との比較</A></H3><P> <CODE><SPAN class="keyword">or</SPAN></CODE> 文は Prolog で対応する構造には単純に書き換えられません。Prolog の選言 <CODE>P&nbsp;;&nbsp;Q</CODE> は常にバックトラックの対象となる選択ポイント(choice point)を生成します。 </P><H2><A name="label72">12.5決定性駆動実行(Determinacy Driven Execution)</A></H2><P>Oz の <CODE><SPAN class="keyword">or</SPAN></CODE> 文は計算が決定性の状態に同期したプログラミングスタイルの純粋な論理形式を許します。以下のプログラムについて考えましょう。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Ints</SPAN>&nbsp;N&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">or</SPAN>&nbsp;N&nbsp;=&nbsp;0&nbsp;Xs&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;<SPAN class="keyword">&gt;</SPAN>&nbsp;0&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;Xs&nbsp;=&nbsp;N<SPAN class="keyword">|</SPAN>Xr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Ints&nbsp;N<SPAN class="keyword">-</SPAN>1&nbsp;Xr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sum3</SPAN>&nbsp;Xs&nbsp;N&nbsp;R}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">or</SPAN>&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;R&nbsp;=&nbsp;N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;=&nbsp;Xs&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Sum3&nbsp;Xr&nbsp;X<SPAN class="keyword">+</SPAN>N&nbsp;R}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sum</SPAN>&nbsp;Xs&nbsp;R}&nbsp;{Sum3&nbsp;Xs&nbsp;0&nbsp;R}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;N&nbsp;S&nbsp;R&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Ints&nbsp;N&nbsp;S}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Sum&nbsp;S&nbsp;{Browse}}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;N&nbsp;=&nbsp;1000<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>スレッドが <CODE>Ints</CODE> を実行する時は <CODE>N</CODE> が分かるまで一時停止します、なぜならその選言で得られるものか決定出来ないので。同じ様に、<CODE>Sum3</CODE> はリスト <CODE>S</CODE> が分かるまで待機するでしょう。<CODE>S</CODE> は漸増的に定義されるでしょう、また、それは <CODE>Sum3</CODE> の中断と再開を導くでしょう。メインスレッドが <CODE>N</CODE> を <CODE>1000</CODE> に束縛した時に物事が動き出します。これは決定性駆動実行が擬似生産者/消費者の振る舞いに必要な同期情報を与えている事を明確に示します。 </P><H2><A name="label73">12.6条件(conditional)</A></H2><H3><A name="label74">12.6.1論理条件(logical condition)</A></H3><P>論理条件は以下の形式を持つ文です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">cond</SPAN>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>ここで <I>Xi</I> は新しく導入された変数で、<I>Si</I> は文です。<I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I> は条件の節で、<I>S2</I> は代替です。 </P><P><CODE><SPAN class="keyword">cond</SPAN></CODE> 文は以下の意味論を持っています。スレッドは空間 <I>SP</I> の文を実行していると仮定する。 </P><UL><LI><P>スレッドはブロックされる。 </P></LI><LI><P>空間 <IMG alt="SP_1" src="latex27.png"> が、ガード部 <CODE><SPAN class="keyword">cond</SPAN>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I> を実行する単一のスレッドとともに生成されます。 </P></LI><LI><P>父スレッドの実行は <IMG alt="SP_1" src="latex27.png"> が含意か非含意となるまでブロックされたままになります。これらの条件は決して起きない事に注意して下さい、例えば、いくつかのスレッド <IMG alt="SP_1" src="latex27.png"> で一時停止か永遠に走る時。 </P></LI><LI><P><IMG alt="SP_1" src="latex27.png"> が非含意なら、父スレッドは <I>S2</I> で実行を続けます。 </P></LI><LI><P><IMG alt="SP_1" src="latex27.png"> が含意なら、ストア <IMG alt="\theta" src="latex26.png"> と ローカル変数 <IMG alt="SX" src="latex28.png"> に縮退(reduce)したと仮定します。この場合、空間は親空間に併合されます。<IMG alt="\theta" src="latex26.png"> と <IMG alt="SX" src="latex28.png"> は親空間に追加され、父スレッドは <I>S1</I> の実行を続けます。 </P></LI></UL><P> </P><H3><A name="label75">12.6.2Prolog との比較</A></H3><P> <CODE><SPAN class="keyword">cond</SPAN></CODE> 文は Prolog の条件 <CODE>&nbsp;P&nbsp;<SPAN class="keyword">-&gt;</SPAN>&nbsp;Q&nbsp;;&nbsp;R&nbsp;</CODE> に大方対応するものとして単に記述されます。Oz は変数のスコープに関して少しより注意深く、ローカル変数 <I>Xi</I> は明示的に導入されなければなりません。<CODE><SPAN class="keyword">cond</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;P&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Q&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;R&nbsp;<SPAN class="keyword">end</SPAN></CODE> は常に論理の意味論 <IMG alt="\exists X : P \wedge Q \vee (\not \exists X : P) \wedge R" src="latex29.png"> を持っており、それは Oz の論理部分にべったり依存しています。これは Prolog では常に true であるわけではありません。 </P><H3><A name="label76">12.6.3並列(parallel)の条件</A></H3><P>並行条件は次の形式です </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">cond</SPAN>&nbsp;</CODE><I>G1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>G2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>SN</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>並行条件は全ての条件 <I>G1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>G(N-1)</I> を<EM>任意(arbitrary)</EM>の順で評価する事で実行され、それぞれの自らの空間を持っており、おそらく並行性を持ちます。空間の一つが <I>Gi</I> と言って、含意されると、対応する文 <I>Si</I> が父スレッドによって選択されます。全ての空間が失敗すると、else 文 <I>SN</I> が選択され、そうでなければスレッドの実行は一時停止します。 </P><P> 並行条件は主に並行プログラミングにおいて有用です、例えば特定のイベントでタイムアウトするかどうかのプログラミングのために。この構造は並行論理プログラミング言語(comitted-choice 言語としても知られる)で基本的な構造です。 </P><P> 並行論理プログラミングの典型例として、2つのストリーム <CODE>Xs</CODE> と <CODE>Ys</CODE> の到着のタイミングが結果ストリーム <CODE>Zs</CODE> の順番を決定するような、非決定バイナリマージを定義しましょう。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Merge</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">cond</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs&nbsp;=&nbsp;Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Ys&nbsp;=&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs&nbsp;=&nbsp;Xr<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr&nbsp;{Merge&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Y&nbsp;Yr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Ys&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>Yr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>Zr&nbsp;{Merge&nbsp;Xs&nbsp;Yr&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> この一般的なバイナリストリームマージは非効率的です、複数のこれらがシンプルなサーバスレッドへの複数スレッドの接続として使われるとなおさらです。定時間の複数マージ演算を実装するための効率的な方法はセルとストリームを代わりに使う事によって下で定義されます。手続き <CODE>{MMerge&nbsp;STs&nbsp;L}</CODE> はどちらも nil かもしれない2つの引数 STs を取ります、マージするためのストリームのリスト、または形式 <CODE>merge(ST1&nbsp;ST2)</CODE> ここで各 <CODE>STi</CODE> は再び同じ形式 <CODE>STs</CODE> として。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MMerge</SPAN>&nbsp;STs&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;{NewCell&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MM</SPAN>&nbsp;STs&nbsp;S&nbsp;E}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;STs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;ST<SPAN class="keyword">|</SPAN>STr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;ST&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;ST1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Exchange&nbsp;C&nbsp;X<SPAN class="keyword">|</SPAN>ST1&nbsp;ST1}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M=S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{MM&nbsp;STr&nbsp;M&nbsp;E}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;merge(STs1&nbsp;STs2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{MM&nbsp;STs1&nbsp;S&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{MM&nbsp;STs2&nbsp;M&nbsp;E}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;E<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{MM&nbsp;&nbsp;STs&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;E}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;E<SPAN class="keyword">==unit</SPAN>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;L&nbsp;=&nbsp;nil&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> バイナリマージ <CODE>{Merge&nbsp;X&nbsp;Y&nbsp;Z}</CODE> は単に <CODE>{MMerge&nbsp;[X&nbsp;Y]&nbsp;Z}</CODE> となります。</P><H2><A name="label77">12.7非決定性(nondeterministic)プログラムと探索(search)</A></H2><P>Oz は Prolog と同じくらい多くの非決定性と探索試行プログラミングを許します。この種のプログラミングは Prolog とは少し違った風味があります。Prolog はバックトラック(backtrack)を基礎としたデフォルトの探索戦略とともにありますが、Oz はプログラマに問題固有の非決定性から分離し直交した方法で彼らに適した探索戦略を工夫する事を許します。</P><P> これを Oz で行うには、選択点(choice point)がどの様に探られるかを指定する事なしに選択点を生成する言語的構造を指定しなくてはいけません。完全に分離したプログラムは探索戦略を指定出来ます。 </P><H3><A name="label78">12.7.1 <CODE><SPAN class="keyword">dis</SPAN></CODE> 構造</A></H3><P>以下のプログラムは Oz の <CODE><SPAN class="keyword">dis</SPAN></CODE> 構造を使って必要時に選択点を生成しています。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;Ys&nbsp;=&nbsp;Zs&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;Xr&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Append&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>これは大体において Prolog の <CODE>append<SPAN class="keyword">/</SPAN>3</CODE> プログラムに対応します: </P><BLOCKQUOTE class="code"><CODE>append(<SPAN class="keyword">[],</SPAN>&nbsp;Ys<SPAN class="keyword">,</SPAN>&nbsp;Ys)<SPAN class="keyword">.</SPAN>&nbsp;<BR>append([X<SPAN class="keyword">|</SPAN>Xr]<SPAN class="keyword">,</SPAN>&nbsp;Ys<SPAN class="keyword">,</SPAN>&nbsp;[X<SPAN class="keyword">|</SPAN>Zr])&nbsp;:<SPAN class="keyword">-</SPAN>&nbsp;append(Xr<SPAN class="keyword">,</SPAN>&nbsp;Yr<SPAN class="keyword">,</SPAN>&nbsp;Zr)<SPAN class="keyword">.</SPAN></CODE></BLOCKQUOTE><P></P><P>実際に <CODE><SPAN class="keyword">or</SPAN></CODE> のために保持されている略語の同じ種が <CODE><SPAN class="keyword">dis</SPAN></CODE> のためにも保持されています。これは上のプログラムが以下の略語の形式を持っているという事です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;Ys&nbsp;=&nbsp;Zs&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;Xr&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Append&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> 以下の手続き呼び出しを仮定して下さい: </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Append&nbsp;[1&nbsp;2&nbsp;3]&nbsp;[a&nbsp;b&nbsp;c]&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>これは <CODE><SPAN class="keyword">or</SPAN></CODE> 構造と全く同じ振る舞いをするでしょう、つまり、これは決定性で <CODE>X</CODE> を <CODE>[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]</CODE> に束縛するでしょう。もし私達が他方を試すと: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Append&nbsp;X&nbsp;Y&nbsp;[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]}<BR>&nbsp;&nbsp;{Browse&nbsp;X<SPAN class="keyword">#</SPAN>Y}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> その振る舞いは <CODE><SPAN class="keyword">or</SPAN></CODE> 構造によるものと同じに見えるでしょう; この順列の呼び出しによるスレッド実行は <CODE>{Append&nbsp;X&nbsp;Y&nbsp;[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]}</CODE> の実行の間一時停止するでしょう。しかしそこには違いがあります。. <CODE>Append</CODE> の呼び出しは選択点を2つの代替とともに生成するでしょう: </P><UL><LI><P><CODE>X&nbsp;=&nbsp;nil&nbsp;Y&nbsp;=&nbsp;[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN></CODE></P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE>Xr&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;1<SPAN class="keyword">|</SPAN>Xr&nbsp;Zr&nbsp;=&nbsp;[2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Append&nbsp;Xr&nbsp;Y&nbsp;Zr}</CODE></BLOCKQUOTE><P></P></LI></UL><P> </P><H3><A name="label79">12.7.2定義節文法(Define Clause Grammer)</A></H3><P> </P><BLOCKQUOTE class="code"><CODE>Sentence(P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;NounPhrase(X&nbsp;P1&nbsp;P)&nbsp;VerbPhrase(X&nbsp;P1)<BR>NounPhrase(X&nbsp;P1&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;Determiner(X&nbsp;P2&nbsp;P1&nbsp;P)&nbsp;Noun(X&nbsp;P3)&nbsp;RelClause(X&nbsp;P3&nbsp;P2)&nbsp;&nbsp;<BR>NounPhrase(X&nbsp;P&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;Name(X)<BR>VerbPhrase(X&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;TransVerb(X&nbsp;Y&nbsp;P1)&nbsp;NounPhrase(Y&nbsp;P1&nbsp;P)&nbsp;<SPAN class="keyword">|</SPAN>&nbsp;InstransVerb(X&nbsp;P)<BR>RelClause(X&nbsp;P1&nbsp;and(P1&nbsp;P2))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[that]&nbsp;VerbPhrase(X&nbsp;P2)&nbsp;&nbsp;<BR>RelClause(_&nbsp;P&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<BR>Determiner(X&nbsp;P1&nbsp;P2&nbsp;all(X&nbsp;imp(P1&nbsp;P2)))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[every]&nbsp;&nbsp;<BR>Determiner(X&nbsp;P1&nbsp;P2&nbsp;exits(X&nbsp;and(P1&nbsp;P2)))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[a]<BR>Noun(X&nbsp;man(X))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[man]&nbsp;&nbsp;<BR>Noun(X&nbsp;woman(X))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[woman]<BR>name(john)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[john]&nbsp;&nbsp;<BR>name(jan)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[jan]<BR>TransVerb(X&nbsp;Y&nbsp;loves(X&nbsp;Y))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[loves]<BR>IntransVerb(X&nbsp;lives(X))&nbsp;&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[lives]</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sentence</SPAN>&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;X&nbsp;P1&nbsp;S1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{NounPhrase&nbsp;X&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S1}<BR>&nbsp;&nbsp;&nbsp;{VerbPhrase&nbsp;X&nbsp;P1&nbsp;S1<SPAN class="keyword">#</SPAN>S}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NounPhrase</SPAN>&nbsp;X&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2&nbsp;P3&nbsp;S1&nbsp;S2&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Determiner&nbsp;X&nbsp;P2&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S1}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Noun&nbsp;X&nbsp;P3&nbsp;S1<SPAN class="keyword">#</SPAN>S2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RelClause&nbsp;X&nbsp;P3&nbsp;P2&nbsp;S2<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;{Name&nbsp;X&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1&nbsp;=&nbsp;P<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">VerbPhrase</SPAN>&nbsp;X&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;P1&nbsp;S1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{TransVerb&nbsp;X&nbsp;Y&nbsp;P1&nbsp;S0<SPAN class="keyword">#</SPAN>S1}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NounPhrase&nbsp;Y&nbsp;P1&nbsp;P&nbsp;S1<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;{IntransVerb&nbsp;X&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">TransVerb</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;loves<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;Z&nbsp;=&nbsp;loves(X&nbsp;Y)<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IntransVerb</SPAN>&nbsp;X&nbsp;Y&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;lives<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;lives(X)<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Name</SPAN>&nbsp;X&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;john<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;jan<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Noun</SPAN>&nbsp;X&nbsp;Y&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;man<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;man(X)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;S0&nbsp;=&nbsp;woman<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;woman(X)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Determiner</SPAN>&nbsp;X&nbsp;P1&nbsp;P2&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;every<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;all(X&nbsp;imp(P1&nbsp;P2))<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;S0&nbsp;=&nbsp;a<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;exists(X&nbsp;and(P1&nbsp;P2))<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">RelClause</SPAN>&nbsp;X&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;P2&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;that<SPAN class="keyword">|</SPAN>S1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;and(P1&nbsp;P2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{VerbPhrase&nbsp;X&nbsp;P2&nbsp;S1<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;S0&nbsp;=&nbsp;S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;P1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Main</SPAN>&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;{Sentence&nbsp;P&nbsp;[every&nbsp;man&nbsp;that&nbsp;lives&nbsp;loves&nbsp;a&nbsp;woman]<SPAN class="keyword">#</SPAN>nil}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><H3><A name="label80">12.7.3いくつかの探索手続き</A></H3><H3><A name="label81">12.7.4dis 構造</A></H3><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Edge<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Connected</SPAN>&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Edge&nbsp;X&nbsp;Y}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Edge&nbsp;X&nbsp;Z}&nbsp;&nbsp;{Connected&nbsp;Z&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Edge</SPAN>&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;1&nbsp;Y&nbsp;=&nbsp;2<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;2&nbsp;Y&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;2&nbsp;Y&nbsp;=&nbsp;3<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;3&nbsp;Y&nbsp;=&nbsp;4<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;2&nbsp;Y&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;5&nbsp;Y&nbsp;=&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;4&nbsp;Y&nbsp;=&nbsp;6<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;6&nbsp;Y&nbsp;=&nbsp;7<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;6&nbsp;Y&nbsp;=&nbsp;8<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;1&nbsp;Y&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;5&nbsp;Y&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>{ExploreOne<BR>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">#</SPAN>Y&nbsp;=&nbsp;L&nbsp;{Connected&nbsp;X&nbsp;Y}<BR>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>}<BR>{Browse<BR>&nbsp;{SearchAll<BR>&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">#</SPAN>Y&nbsp;=&nbsp;L&nbsp;{Connected&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;}}</CODE></BLOCKQUOTE><P></P><H3><A name="label82">12.7.5否定(negation)</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NotP</SPAN>&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;{SearchOne&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;L}&nbsp;{P}&nbsp;L=<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;$}&nbsp;=&nbsp;nil<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ConnectedEnh</SPAN>&nbsp;X&nbsp;Y&nbsp;Visited}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Edge&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Edge&nbsp;X&nbsp;Z}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NotP&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Member&nbsp;Z&nbsp;Visited}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ConnectedEnh&nbsp;Z&nbsp;Y&nbsp;Z<SPAN class="keyword">|</SPAN>Visited}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label83">12.7.6動的述語(dynamic predicate)</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">DisMember</SPAN>&nbsp;X&nbsp;Ys}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;Ys&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>_&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Yr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Ys&nbsp;=&nbsp;_<SPAN class="keyword">|</SPAN>Yr&nbsp;{DisMember&nbsp;X&nbsp;Yr}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">DataBase</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;d<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{NewDictionary}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">dic</SPAN>($)&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">tell</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;{IsFree&nbsp;I<SPAN class="keyword">.</SPAN>1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;database(nonground(I))&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;=&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>condGet&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;I<SPAN class="keyword">.</SPAN>1&nbsp;nil}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>put&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;I<SPAN class="keyword">.</SPAN>1&nbsp;{Append&nbsp;Is&nbsp;[I]}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">ask</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;{IsFree&nbsp;I}&nbsp;<SPAN class="keyword">orelse</SPAN>&nbsp;{IsFree&nbsp;I<SPAN class="keyword">.</SPAN>1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{DisMember&nbsp;I&nbsp;{Flatten&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>items&nbsp;<SPAN class="keyword">@</SPAN>d}}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{DisMember&nbsp;I&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>condGet&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;I<SPAN class="keyword">.</SPAN>1&nbsp;nil}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">entries</SPAN>($)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>entries&nbsp;<SPAN class="keyword">@</SPAN>d}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Dynamic</SPAN>&nbsp;?Pred}<BR>&nbsp;&nbsp;&nbsp;Pred&nbsp;=&nbsp;{New&nbsp;DataBase&nbsp;init}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Assert</SPAN>&nbsp;P&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;{P&nbsp;tell(I)}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Query</SPAN>&nbsp;P&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;{P&nbsp;ask(I)}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>EdgeP&nbsp;=&nbsp;{Dynamic}<BR>{ForAll<BR>[edge(1&nbsp;2)<BR>&nbsp;edge(2&nbsp;1)&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;Cycle<BR></SPAN>&nbsp;edge(2&nbsp;3)<BR>&nbsp;edge(3&nbsp;4)<BR>&nbsp;edge(2&nbsp;5)<BR>&nbsp;edge(5&nbsp;6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;edge(4&nbsp;6)<BR>&nbsp;edge(6&nbsp;7)<BR>&nbsp;edge(6&nbsp;8)<BR>&nbsp;edge(1&nbsp;5)<BR>&nbsp;edge(5&nbsp;1)&nbsp;&nbsp;<SPAN class="comment">%&nbsp;Cycle<BR></SPAN>]<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Assert&nbsp;EdgeP&nbsp;I}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>}</CODE></BLOCKQUOTE><P> </P><H3><A name="label84">12.7.7基本的な space ライブラリ</A></H3><H3><A name="label85">12.7.8例: シンプルなエキスパートシステム(expert system)</A></H3></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node11.html#chapter.objectscc">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="bib.html#label86">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
