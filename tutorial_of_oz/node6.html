<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>6 Functions</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node5.html#chapter.control">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node7.html#chapter.modules">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.functional"><H1><A name="chapter.functional">6 Functions</A></H1><H2><A name="label41">6.1関数記法(functional notation)</A></H2><P>Oz は関数記法を構文の利便性のために提供しています。私達は手続き呼び出しとして見た: </P><BLOCKQUOTE class="code"><CODE>{P&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn&nbsp;R}</CODE></BLOCKQUOTE><P> これをネストした式の中で関数呼び出しとして使う事が出来ます: </P><BLOCKQUOTE class="code"><CODE>{P&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}</CODE></BLOCKQUOTE><P> Oz は手続きのための直接の構文記法として関数抽象も許します。それゆえ、以下の関数定義で: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">F</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;</CODE><I>S</I><CODE>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> <I>S</I> は文で <I>E</I> は以下の関数定義に対応する式です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">F</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn&nbsp;R}&nbsp;</CODE><I>S</I><CODE>&nbsp;R=</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P class="warning"><STRONG>注意:</STRONG>手続き定義への変換も含めた関数のための厳密な構文は <A href="../notation/index.html"><EM>The Oz Notation Reference Manual</EM></A> に定義されています。 </P><P>ここでは私達は読者の直観にたよります。大雑把に言うと、関数の構文の形式のための一般的なルールは手続きのそれと非常に似て見えます。その例外として、手続きでは制御のスレッドは文で終わり、対応する関数は式で終わるという事があります。 </P><P><A href="node6.html#checkbintreelazy3">Figure&nbsp;6.1</A> で示されるプログラムは <A href="node5.html#checkbintreelazy">Figure&nbsp;5.7</A> で示されるプログラムと機能的に等しいものです。<CODE>AndThen<SPAN class="keyword">/</SPAN>2</CODE> がどの様に手続き <CODE>AndThen<SPAN class="keyword">/</SPAN>3</CODE> に展開されるかをよく見て下さい。下で、変換プロセスの直観的理解を与えるいくつものステップをお見せします。全ての中間の形式は正しい Oz のプログラムです。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>結果変数 <CODE>B</CODE> を導入する事によって手続きを作ります: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>結果変数を外側の <EM>if-式</EM> に移動して <EM>if-文</EM> を作ります: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="checkbintreelazy3"><HR><P><A name="checkbintreelazy3"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;構文変換:&nbsp;関数記法<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{AndThen<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{BinaryTree&nbsp;T1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{BinaryTree&nbsp;T2}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;6.1:</STRONG> 遅延二分木チェック</P><HR></DIV><P> </P><P>もしあなたが関数型プログラマーなら、元気を出して下さい。あなたは高階関数を含むあなた自身の関数を持てます、そして遅延評価の関数型言語と同様に、Oz は正格評価の関数型言語 <A href="node6.html#label44"><SUP>1</SUP></A> Standard ML、Scheme、そして並行関数型言語 Erlang には無い末尾再帰の特定の形式を許します。しかしながら、Oz では標準の関数定義は遅延ではありません。遅延関数は Oz <A href="node6.html#label45"><SUP>2</SUP></A> においてもサポートされます。 </P><P>ここで、よく知られた高階関数 <CODE>Map<SPAN class="keyword">/</SPAN>2</CODE> の例をお見せします。これは Standard ML や Scheme においては末尾再帰ではありませんが、Oz においては末尾再帰です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Map</SPAN>&nbsp;Xs&nbsp;F}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{F&nbsp;X}<SPAN class="keyword">|</SPAN>{Map&nbsp;Xr&nbsp;F}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>{Browse&nbsp;{Map&nbsp;[1&nbsp;2&nbsp;3&nbsp;4]&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;X<SPAN class="keyword">*</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN>}}</CODE></BLOCKQUOTE><P> </P><H3><A name="label42">6.1.1 <CODE><SPAN class="keyword">andthen</SPAN></CODE> と <CODE><SPAN class="keyword">orelse</SPAN></CODE></A></H3><P>結局、私達は多くの仕事を無料でしてきました！Oz は既に遅延(非正格)バージョンの Boolean 関数 <CODE>And<SPAN class="keyword">/</SPAN>2</CODE> と <CODE>Or<SPAN class="keyword">/</SPAN>2</CODE> をそれぞれ <CODE><SPAN class="keyword">andthen</SPAN></CODE> と <CODE><SPAN class="keyword">orelse</SPAN></CODE> として提供しています。前者は関数 <CODE>AndThen<SPAN class="keyword">/</SPAN>2</CODE> の様に振る舞い、後者は最初の引数が <CODE><SPAN class="keyword">false</SPAN></CODE> と評価された場合のみ評価されます。通常、これらの演算子はプリミティブではなく、Oz で定義されます。<A href="node6.html#checkbintreelazy4">Figure&nbsp;6.2</A> は関数 <CODE>BinaryTree</CODE> の最終版です。 </P><P></P><DIV class="figure" id="checkbintreelazy4"><HR><P><A name="checkbintreelazy4"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{BinaryTree&nbsp;T1}&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;{BinaryTree&nbsp;T2}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;6.2:</STRONG> 遅延二分木チェック</P><HR></DIV><P> </P><H3><A name="label43">6.1.2関数にするか関数にしないか？</A></H3><P>今から、原則として、私達は手続きと関数の両方を使う事によっていくらかの構文的な重複を持っていますが、問いはいつ関数記法を使っていつ使わないのかです。誠実な回答は、「それはあなたの責任です」となります！私の個人的な意見を述べましょう。いくつかのルールの概要です: </P><UL><LI><P>最初に、私が好きではないものです。手続き <CODE>P</CODE> を定義してそれを関数として呼び出さない事、つまり手続きのために関数ネストを使わない事。<CODE>SMerge</CODE> の例の中での様に、ネストマーカーの代わりに手続きネストを使う事。さらに言うと、関数を定義したら、それを関数として呼ぶ事。 </P></LI><LI><P>私は、対象が本当に関数的、すなわち、一つの出力、複数の入力、そして出力が入力引数の数学的関数となっているのであれば、関数定義を使うのを好みます。 </P></LI><LI><P>私はその他の場合、すなわち、複数の出力、状態を持つデータ型の様な関数的でない定義、非決定的な定義であるその他多くの場合には手続きを使うのを好みます <A href="node6.html#label46"><SUP>3</SUP></A> 。 </P></LI><LI><P>厳密には関数的でない定義であっても情報の流れの明確な方向性があれば、前のルールを緩めて関数を使っても良いかもしれません。こうすれば関数は簡潔になります。 </P></LI></UL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node5.html#chapter.control">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node7.html#chapter.modules">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label44">1. </A>正格評価関数型言語は関数の実行の前に全ての引数を評価します。</DIV><DIV class="footnote"><A name="label45">2. </A>これらは後で <EM>フューチャ(future)</EM> と by need 同期を論じる時に述べます。</DIV><DIV class="footnote"><A name="label46">3. </A>実際には、これらのケースでは Oz のオブジェクト指向スタイルが最も適切です。</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
