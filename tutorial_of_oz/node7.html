<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>7 Modules and Interfaces</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#chapter.functional">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#chapter.concurrency">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.modules"><H1><A name="chapter.modules">7 Modules and Interfaces</A></H1><P>パッケージとしても知られているモジュールは、手続きと値のコレクションで<A href="node7.html#label47"><SUP>1</SUP></A>、特定の関連する機能を提供するために一緒に構築されます。典型的なモジュールは、モジュールの外側からは見えないいくつものプライベート手続きとモジュールの外側に提供するいくつものインターフェース手続きを持ちます。Oz にはモジュール指定のための構文サポートがあります。この概念が使われたものは<EM>ファンクタ(functor)</EM>と呼ばれます。ファンクタはモジュールのコンポーネントを指定する式です。Mozart システムはモジュールマネージャの助けを借りてファンクタをモジュールに変換します。 </P><P>モジュールがどんなものなのかを見て、モジュールを指定する対応するファンクタを見ましょう。一般的に、モジュールはたくさんのローカルで定義されたエンティティ(entity 実体)です、例えば手続き、オブジェクト、レコードインターフェースを通じてアクセス出来る物がそうです。append, sort, 含まれるメンバのテストのためにいくつものインターフェース手続きを持つ <CODE>List</CODE> と呼ばれるモジュールを構築したいと想定しましょう。これは以下の様に見えるでしょう。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;List&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MergeSort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{MergeSort&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Member</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;<SPAN class="string">'export'</SPAN>(append:&nbsp;Append<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort:&nbsp;Sort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member:&nbsp;Member<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE>List</CODE> の外側からの <CODE>Append</CODE> 手続きへのアクセスは、フィールド <CODE>append</CODE> を使って <EM>record</EM> <CODE>List</CODE>: <CODE>List<SPAN class="keyword">.</SPAN>append</CODE> から行われます。上の例では手続き <CODE>MergeSort</CODE> はモジュールのプライベートな物である事に注目して下さい。Mozart の基本的なライブラリモジュールのほとんどは上の構造をなぞっています。上のモジュールは以下で見るファンクタから作る事が出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">export</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;append:Append<BR>&nbsp;&nbsp;sort:Sort<BR>&nbsp;&nbsp;member:Member<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MergeSort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{MergeSort&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Member</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> このファンクタが例えば '/home/xxx/list.ozf' に保存されると想定すると、モジュールは以下の様に生成する事が出来ます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;[List]=&nbsp;{Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">'/home/xxx/list.ozf'</SPAN>]}</CODE></BLOCKQUOTE><P></P><P> <CODE>Module<SPAN class="keyword">.</SPAN>link<SPAN class="keyword">/</SPAN>2</CODE> はモジュール <CODE>Module</CODE> で定義された関数でファンクタのリストを取ってリンクし、対応するモジュールのリストを返します。 </P><P>ファンクタは import 宣言を持つかもしれません。あなたがシステムモジュールをインポートしたいのなら、そのファンクタを記述するだけでよいです。別のユーザ定義のモジュールのインポートの手法は、ファンクタが保存されているファイルのURLの記述を必要とします。 </P><P> 以下のファンクタについて考えましょう。 </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;<BR><SPAN class="keyword">functor</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Browser&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;FO&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'file:///home/seif/FileOperations.ozf'</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browser<SPAN class="keyword">.</SPAN>browse&nbsp;{FO<SPAN class="keyword">.</SPAN>countLines&nbsp;<SPAN class="string">'/etc/passwd'</SPAN>}}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;</CODE></BLOCKQUOTE><P> </P><P> <CODE><SPAN class="keyword">import</SPAN></CODE> 宣言はシステムモジュール <CODE>Browser</CODE> をインポートし、手続き <CODE>Browser<SPAN class="keyword">.</SPAN>browse</CODE> を使います。それはまたファイル <CODE><SPAN class="string">'/home/seif/FileOperations.ozf'</SPAN></CODE> に保存されたファンクタによって指定されるモジュール <CODE>FO</CODE> をインポートし、引数で与えられたファイルの行数をカウントする手続き <CODE>FO<SPAN class="keyword">.</SPAN>countLines</CODE> を呼び出します。このファンクタはその効果のために定義され、それゆえにインターフェースをエクスポートしません。このファンクタがリンクされると、<CODE><SPAN class="keyword">define</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> の間の文が実行されます。 </P><P class="warning"><STRONG>注意:</STRONG>ファンクタを定義しているファイル <CODE><SPAN class="string">'x.oz'</SPAN></CODE> があるとすると、あなたは対応するファンクタ <CODE><SPAN class="string">'x.ozf'</SPAN></CODE> をシェルで次のコマンドを打ち込んで作れます: </P><BLOCKQUOTE class="code"><CODE>&nbsp;ozc&nbsp;<SPAN class="keyword">-</SPAN>c&nbsp;x<SPAN class="keyword">.</SPAN>ozf&nbsp;</CODE></BLOCKQUOTE><P class="warning"> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#chapter.functional">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#chapter.concurrency">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label47">1. </A>Classes, objects, etc.</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
