<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>5 Basic Control Structures</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.equality">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.functional">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.control"><H1><A name="chapter.control">5 Basic Control Structures</A></H1><P>私達は既にいくつかの Oz の基本的な文(statement)を見てきました。新しい変数の導入と文のシーケンス: </P><BLOCKQUOTE class="code"><I>S1</I><CODE>&nbsp;&nbsp;&nbsp;</CODE><I>S2</I></BLOCKQUOTE><P> </P><P>再度繰り返しますが、スレッドは文をシーケンシャルな順序で実行します。しかしながらスレッドは、保守的な言語とは対照的に、いくつかの文で一時停止するかもしれず、それゆえ上において、スレッドは <I>S2</I> が始まる前に <I>S1</I> の実行を完了しなければなりません。事実、<I>S1</I> 中で例外が発生した場合など、<I>S2</I> が全く実行されない事もあります。 </P><H2><A name="label28">5.1 skip</A></H2><P><CODE><SPAN class="keyword">skip</SPAN></CODE> 文は空の文です。 </P><DIV id="control.if"><H2><A name="control.if">5.2If 文</A></H2><P>Oz は以下の形式のシンプルな条件文を提供します: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;B&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE>B</CODE> はブール値であるべきです。 </P><H3><A name="label29">5.2.1意味論(semantics)</A></H3><P></P><UL><LI><P><CODE>B</CODE> が <CODE><SPAN class="keyword">true</SPAN></CODE> に束縛されていれば <I>S1</I> が実行されます。 </P></LI><LI><P><CODE>B</CODE> が <CODE><SPAN class="keyword">false</SPAN></CODE> に束縛されていれば <I>S2</I> が実行されます。 </P></LI><LI><P><CODE>B</CODE> が非ブール値に束縛されていれば、例外が発生します。 </P></LI><LI><P>または <CODE>B</CODE> が束縛されていなければ、上記のどれかが適用されるまでスレッドは一時停止します。 </P></LI></UL><P> </P><P class="margin">比較(comparison)手続き</P><P> Oz は比較のためにいくつもの組込の3番地コード形式の手続き(tertiary procedure)を提供しています。これらは私達が前に目にした <CODE><SPAN class="keyword">==</SPAN></CODE> と同様に <CODE><SPAN class="keyword">\=</SPAN></CODE>, <CODE><SPAN class="keyword">=&lt;</SPAN></CODE>, <CODE><SPAN class="keyword">&lt;</SPAN></CODE>, <CODE><SPAN class="keyword">&gt;=</SPAN></CODE>, <CODE><SPAN class="keyword">&gt;</SPAN></CODE> を含みます。これらの手続きは、中置の演算子としてブール値を返す関数であるという事が共通しています。以下の例は If 文の中でのより大きい(greater-than)演算子 <CODE><SPAN class="keyword">&gt;</SPAN></CODE> を使用を示します(訳注: 以下で実際に使われてる &gt;= はgte(greater-than-or-equal)ですが…)。 </P><P>この例では <CODE>Z</CODE> が <CODE>X</CODE> と <CODE>Y</CODE> のうち大きな方に束縛されます(つまり <CODE>Y</CODE> ):</P><P></P><DIV class="figure" id="casestatement"><HR><P><A name="casestatement"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5&nbsp;Y&nbsp;=&nbsp;10<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Z&nbsp;=&nbsp;X&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Z&nbsp;=&nbsp;Y&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.1:</STRONG> If 文の使用</P><HR></DIV><P> </P><H3><A name="label30">5.2.2略語(abbreviation)</A></H3><P>キーワード <CODE><SPAN class="keyword">elseif</SPAN></CODE> を使う文: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;</CODE><I>B2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S3</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>はネストした if 文の略式の書き方です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S3</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>else 部の無い if 文: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>は以下と等しいです: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.procedure"><H2><A name="control.procedure">5.3手続き抽象(procedural abstraction)</A></H2><H3><A name="label31">5.3.1手続き定義(procedure definition)</A></H3><P>手続き定義は Oz の主要な(primary)抽象です。手続きは定義可能で、他の手続きに引数として渡す事が出来、レコードにストア出来ます。手続きの定義は以下の構文です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">P</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label32">5.3.2意味論(semantics)</A></H3><P>変数 <CODE>P</CODE> が既に導入されているとすると、上の文の実行は次の様になります: </P><P></P><UL><LI><P>ラムダ(lambda)式と名付けられたユニークなクロージャ(closure)の生成 <IMG alt="\lambda(X_1 \ldots X_N).S" src="latex1.png"> </P></LI><LI><P>変数 <I>P</I> はクロージャに束縛されています。 </P></LI></UL><P> </P><P>Oz の手続きはそのユニークなクロージャによって与えられたユニークな識別子を持っており、それは他の全ての手続きから区別されます。2つの手続きの定義は、たとえそれらの見た目が似ていても、常に異なります。手続きは私達が遭遇する、同等性が名前(name)の同等性に基づいた最初の Oz の値です。その他にはスレッド(thread)、セル(cell)、チャンク(chunk)が含まれます。 </P></DIV><DIV id="control.lexical"><H2><A name="control.lexical">5.4レキシカルスコープ(lexical scoping)</A></H2><P>一般的に、手続き定義の中での文 <I>S</I> は多くの変数の生成(occurrence)を起こします。文の中で記述され生成される変数は識別子であり、実行時に生成されるデータ構造である論理変数とは区別されます。<I>S</I> 中に生成されるいくつかの識別子は<EM>構文的に束縛(syntactically bound)</EM>され、他の物は<EM>自由(free)</EM>です。<I>S</I> で生成される識別子 <I>X</I><A href="node5.html#label38"><SUP>1</SUP></A> は形式的パラメータ <I>X</I> のスコープ内にいれば束縛され、そうでなければ <I>X</I> を導入したスコープでのものに束縛されます。そうでなければ、識別子は自由です。プログラム中の自由な識別子は最終的にはそれぞれ、文脈的に最も近い識別子束縛構造によって束縛されます。 </P><P>私達は既に手続きをどうやって適用するか(呼び出すか)を見ました。私達にとって最初となる手続き定義を示しましょう。<A href="node5.html#casestatement">Figure&nbsp;5.1</A> で、私達は2つの数字リテラルのうち最大のものを計算するやり方を見ました。このコードを手続きに抽象します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Max&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Max</SPAN>&nbsp;X&nbsp;Y&nbsp;Z}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Z&nbsp;=&nbsp;X&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Z&nbsp;=&nbsp;Y&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;10<BR>&nbsp;&nbsp;&nbsp;{Max&nbsp;X&nbsp;Y&nbsp;Z}&nbsp;{Browse&nbsp;Z}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.anonymous"><H2><A name="control.anonymous">5.5匿名手続き(anonymous procedure)と変数初期化(variable initialization)</A></H2><P>ある人はなぜ変数がレコードへの束縛とは違った方法で手続きへ束縛されるのか問うかもしれません。例: <CODE>X&nbsp;=&nbsp;</CODE><I>f(...)</I>答えは、あなたが見ているのは単に同等形式の構文的亜種であるからです。 </P><BLOCKQUOTE class="code"><CODE>P&nbsp;=&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>R.H.S.(訳注:Right-Hand Side 右辺) は<EM>匿名手続き値(anonymous procedural value)</EM>を定義します。これは次と同等です </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">P</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Oz では、<EM>変数初期化同等性(variable-initialization equality)</EM>を使う事によって、変数が導入されると即座に初期化する事が出来ます。 </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;</CODE>&lt;<I>Value</I>&gt;</BLOCKQUOTE><P> または </P><BLOCKQUOTE class="code">&lt;<I>Record</I>&gt;<CODE>&nbsp;=&nbsp;</CODE>&lt;<I>Value</I>&gt;</BLOCKQUOTE><P> </P><P><CODE><SPAN class="keyword">local</SPAN></CODE> と <CODE><SPAN class="keyword">in</SPAN></CODE> の間、文 <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> において。そのため、前の例は匿名手続きを使って以下の様にもかけます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Max&nbsp;=&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Y&nbsp;Z}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Z&nbsp;=&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Z&nbsp;=&nbsp;Y&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;10<BR>&nbsp;&nbsp;&nbsp;Z<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Max&nbsp;X&nbsp;Y&nbsp;Z}&nbsp;{Browse&nbsp;Z}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>さあ、変数初期化をより詳細に理解しましょう。一般的なルールはこうです: 変数初期化同等性では、変数は L.H.S.(Left-Hand Side 左辺)でのみ発生する。同等性は導入されたものについてのものである。以下の例を考えましょう: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;1<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;=&nbsp;f(M&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[X1&nbsp;Y]&nbsp;=&nbsp;L<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Browse&nbsp;[M&nbsp;L]}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>最初 <CODE>Y</CODE> が導入され、外側の <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> で初期化されます。そして、内部の <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> で全ての左辺が導入されます、例として <CODE>M</CODE>, <CODE>Y</CODE>, <CODE>X1</CODE>, <CODE>L</CODE>。それゆえ、外側の変数 <CODE>Y</CODE> は最内の <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> 文では不可視となっています。上の文は次と同等です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;M&nbsp;X1&nbsp;Y&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;=&nbsp;f(M&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[X1&nbsp;Y]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;[M&nbsp;L]}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>もし私達が <CODE>Y</CODE> を外側のスコープのものとして表現したいのなら 内側の左辺での初期化同等性での <CODE>Y</CODE> の導入を、以下の様なエクスクラメーションマーク <CODE><SPAN class="keyword">!</SPAN></CODE> を使う事によって抑制しなければいけません。エクスクラメーションマーク <CODE><SPAN class="keyword">!</SPAN></CODE> は初期化同等性の左辺でのみ意味を成します <A href="node5.html#label39"><SUP>2</SUP></A> 。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;1<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;=&nbsp;f(M&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[X1&nbsp;<SPAN class="keyword">!</SPAN>Y]&nbsp;=&nbsp;L<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Browse&nbsp;[M&nbsp;L]}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.pattern"><H2><A name="control.pattern">5.6パターンマッチ(pattern matching)</A></H2><P>とても簡単な例を考えましょう: 二分木への挿入二分木は <CODE>nil</CODE> と表される空のものか、タプル <CODE>tree(Key&nbsp;Value&nbsp;TreeL&nbsp;TreeR)</CODE> …ここで <CODE>Key</CODE> は値 <CODE>Value</CODE> と関連付けられたノードのキーで、 <CODE>TreeL</CODE> は <CODE>Key</CODE> より小さなキーを持つ左部分木、そして  <CODE>TreeR</CODE> は <CODE>Key</CODE> より大きなキーを持つ右部分木…として表されるものかです。手続き <CODE>Insert</CODE> は4つの引数を取り、うち3つは入力用引数 <CODE>Key</CODE>, <CODE>Value</CODE> そして <CODE>TreeIn</CODE> で、1つの出力用引数は挿入後の木の結果に束縛された <CODE>TreeOut</CODE> です。 </P><P>プログラムは <A href="node5.html#treeinsert">Figure&nbsp;5.2</A> に示されます。<CODE>TreeOut</CODE> の前の記号 <CODE>?</CODE> は、引数が出力用引数として振る舞う事を示すために任意に付ける事の出来る <EM>説明用コメント(documentation comment)</EM> です(訳注:付けても付けなくても機能的には変わりませんが読む人に対しての目印として有用です)。手続きの働きは明白です。最初は木が空かどうかをあてにし、後では木中のノードのキーと入力用のキーとの比較をあてにします。<CODE><SPAN class="keyword">if</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> の明白な意味に注目して下さい。 </P><P></P><DIV class="figure" id="treeinsert"><HR><P><A name="treeinsert"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Insert</SPAN>&nbsp;Key&nbsp;Value&nbsp;TreeIn&nbsp;?TreeOut}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;TreeIn&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;nil&nbsp;nil)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T2)&nbsp;=&nbsp;TreeIn&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;T1&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T1&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T2&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.2:</STRONG> 二分木へのノード(キーと値)の挿入</P><HR></DIV><P> </P><P><A href="node5.html#treeinsert">Figure&nbsp;5.2</A> では、次の文で導入されるローカル変数が </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T2)=&nbsp;TreeIn&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN></CODE></BLOCKQUOTE><P> </P><P>暗黙の内にローカルに導入された変数 <CODE>K1</CODE>, <CODE>V1</CODE>, <CODE>T1</CODE> と <CODE>T2</CODE> から抽出されたものとのパターンマッチを行います。 </P><P>Oz はパターン中で暗黙的な変数の導入を許す、明示的なパターンマッチである case 文を提供します。 </P><H3><A name="label33">5.6.1case 文</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">case</SPAN>&nbsp;E&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><I>Pattern_i</I> 中の全変数は暗黙的に定義され、<I>Si</I> までに及ぶスコープを持っています。 </P><H3><A name="label34">5.6.2意味論(semantics)</A></H3><P>式 <CODE>E</CODE> が <CODE>V</CODE> に評価される事について考えてみましょう。case 文の実行はシーケンシャルに順々に <CODE>V</CODE> をパターン <I>Pattern_1</I>, <I>Pattern_2</I>, ...,<I>Pattern_n</I> に対してのマッチングを試みる事です。<CODE>V</CODE> の <CODE>Pattern_i</CODE> に対するマッチングは、左から右(left-to-right)、深さ優先(depth-first)で行われます。 </P><P></P><UL><LI><P>もし <CODE>V</CODE> が <CODE>Pattern_i</CODE> に <CODE>V</CODE> 中で発生するどの変数の束縛もなしにマッチするなら、対応する文 <I>Si</I> が実行されます。 </P></LI><LI><P>もし <CODE>V</CODE> が <CODE>Pattern_i</CODE> に <CODE>V</CODE> で発生するいくつかの変数の束縛とともにマッチするなら、スレッドは一時停止します。 </P></LI><LI><P>もし <CODE>V</CODE> と <CODE>Pattern_i</CODE> のマッチングが失敗すれば、<CODE>V</CODE> は次のパターン <CODE>Pattern_i<SPAN class="keyword">+</SPAN>1</CODE> を試行し、そうでなければ <CODE><SPAN class="keyword">else</SPAN></CODE> 文 <I>S</I> が実行されます。</P></LI></UL><P> </P><P><CODE><SPAN class="keyword">else</SPAN></CODE> 部は省略可能で、その場合に全てのマッチングが失敗すると例外が発生します。 </P><P>再度になりますが、各パターンは新しいローカル変数の導入を <CODE><SPAN class="keyword">!</SPAN></CODE> を使って抑制する事が出来ます。例えば、以下の様に: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">case</SPAN>&nbsp;f(X1&nbsp;X2)&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;f(<SPAN class="keyword">!</SPAN>Y&nbsp;Z)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE>X1</CODE> は外部の変数 <CODE>Y</CODE> に対してマッチします。マッチングの結果を決定する際に、<CODE>X1</CODE> が正しく具体化(instantiated)されていなければ、case 文の実行は一時停止する事を思い出して下さい。<A href="node5.html#treeinsert2">Figure&nbsp;5.3</A> では case 文のマッチングを使った木挿入手続きを示す事によって、この事が全て言い表されています。略記によって構文のネストを減らしてもいます: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;)<BR>&nbsp;&nbsp;{Insert&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>これを次のように: </P><BLOCKQUOTE class="code"><CODE><I>T</I></CODE><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;)<BR>&nbsp;&nbsp;{Insert&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="treeinsert2"><HR><P><A name="treeinsert2"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;パターンマッチのための case<BR></SPAN><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Insert</SPAN>&nbsp;Key&nbsp;Value&nbsp;TreeIn&nbsp;?TreeOut}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;TreeIn<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;nil&nbsp;nil)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;T1&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T1&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T2&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.3:</STRONG> case 文を使った木への挿入</P><HR></DIV><P> </P><P>マッチの対象にするかもしれない式 <I>E</I> は単なる変数ではなく、どんなレコード構造である事も出来ます。これは <A href="node5.html#smerge">Figure&nbsp;5.4</A> に示される様な複数引数のマッチングを許し、ソートされたリスト <CODE>Xs</CODE> と <CODE>Ys</CODE> をソートされたリスト <CODE>Zs</CODE> にマージする事も出来ます。 </P><P></P><DIV class="figure" id="smerge"><HR><P><A name="smerge"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SMerge</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil<SPAN class="keyword">#</SPAN>Ys&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;(X<SPAN class="keyword">|</SPAN>Xr)&nbsp;<SPAN class="keyword">#</SPAN>&nbsp;(Y<SPAN class="keyword">|</SPAN>Yr)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">=&lt;</SPAN>Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{SMerge&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>Zr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{SMerge&nbsp;Xs&nbsp;Yr&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.4:</STRONG> 2つのソートされたリストのマージ</P><HR></DIV><P> </P></DIV><DIV id="control.nesting"><H2><A name="control.nesting">5.7ネスト(nesting)</A></H2><A name="label35"></A><P>私達の <CODE>Insert</CODE> 手続きを <A href="node5.html#treeinsert2">Figure&nbsp;5.3</A> の様に使ってみましょう。以下の文はいくつかのノードを初期状態が空の木に挿入しています。手続き呼び出しの記述を行うためにいくつもの中間変数を導入しなければならない事に注意して下さい。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;T0&nbsp;T1&nbsp;T2&nbsp;T3&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Insert&nbsp;seif&nbsp;43&nbsp;nil&nbsp;T0}<BR>&nbsp;&nbsp;{Insert&nbsp;eeva&nbsp;45&nbsp;T0&nbsp;T1}<BR>&nbsp;&nbsp;{Insert&nbsp;rebecca&nbsp;20&nbsp;T1&nbsp;T2}<BR>&nbsp;&nbsp;{Insert&nbsp;alex&nbsp;17&nbsp;T2&nbsp;T3}<BR>&nbsp;&nbsp;{Browse&nbsp;T3}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Oz は他の文の中の式の位置で一つの手続きをネストする構文サポートを提供しています。それで、一般的には: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{P&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">...</SPAN>}<BR>&nbsp;&nbsp;{Q&nbsp;Y&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>は次の様に書けます: </P><BLOCKQUOTE class="code"><CODE>{Q&nbsp;{P&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;$&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}</CODE></BLOCKQUOTE><P> </P><P><CODE>$</CODE> を <A name="label36"></A> <EM>ネストマーカー(nesting marker)</EM>として使うと、変数 <CODE>Y</CODE> は省略されます。平坦な構文に戻すルールでは、手続き呼び出し中でのネストされた手続き呼び出しは、現在の文の<EM>実行される前に</EM>移動されます; そして一つの新しい変数がネストされた手続き呼び出しを置き換えるように発生し、他はネストマーカーを置き換えるように発生します。 </P><H3><A name="label37">5.7.1関数のネスト(functional nesting)</A></H3><P>ネストの他の形式は関数ネストと呼ばれるものです: 手続き <CODE>{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;R}</CODE> は関数と考えられます; その結果は引数 <CODE>R</CODE> です。それゆえ、<CODE>{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>}</CODE> は結果用引数 <CODE>R</CODE> の代わりにどんな式にも挿入されうる関数呼び出しと考えられます。そのため <CODE>{Q&nbsp;{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}</CODE> は次と等しいです: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;R&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;&nbsp;R}<BR>&nbsp;&nbsp;&nbsp;{Q&nbsp;R&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>今私達の例に戻ると、関数ネストを使ったより適切な形式は: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{Insert&nbsp;alex&nbsp;17&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;rebecca&nbsp;20<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;eeva&nbsp;45&nbsp;{Insert&nbsp;seif&nbsp;43&nbsp;nil}}}}}&nbsp;</CODE></BLOCKQUOTE><P> </P><P>ここに覚えておくもう一つのルールがあります。レコードまたはタプルの中ではそれはネストされたアプリケーションとして次の様に行われなければならないという事です: </P><BLOCKQUOTE class="code"><CODE>Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>{SMerge&nbsp;Xr&nbsp;Ys}</CODE></BLOCKQUOTE><P> </P><P>ここで、ネストされたアプリケーションは、レコード(またはリスト)の構築文の<EM>実行の後に</EM>行われます。それゆえ、私達は次を得ます </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr<BR>&nbsp;&nbsp;&nbsp;{SMerge&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P> この様にすると多くの再帰的手続きは<EM>末尾再帰(tail-recursive)</EM>になります。末尾再帰手続きは繰り返し構築を空間効率良く実行します。 </P><P>私達の <CODE>SMerge</CODE> 手続きを <A href="node5.html#smerge2">Figure&nbsp;5.5</A> に示される様に書き直せます。ここで私達はネストされたアプリケーションを使います。 </P><P></P><DIV class="figure" id="smerge2"><HR><P><A name="smerge2"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SMerge</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil<SPAN class="keyword">#</SPAN>Ys&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;(X<SPAN class="keyword">|</SPAN>Xr)&nbsp;<SPAN class="keyword">#</SPAN>&nbsp;(Y<SPAN class="keyword">|</SPAN>Yr)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">=&lt;</SPAN>Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>{SMerge&nbsp;Xr&nbsp;Ys}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>{SMerge&nbsp;Xs&nbsp;Yr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.5:</STRONG> 2つのソートされたリストのマージをネスト形式で行う</P><HR></DIV><P> </P></DIV><DIV id="control.procasvals"><H2><A name="control.procasvals">5.8値としての手続き</A></H2><P>二分木への要素の挿入を行ったので、適切な二分木の構造を持っているかをチェックするプログラムを定義してみましょう。<A href="node5.html#checkbintree">Figure&nbsp;5.6</A> 中に示される手続き <CODE>BinaryTree</CODE> は構造が二分木かそうでないかを検証し、<CODE><SPAN class="keyword">true</SPAN></CODE> か <CODE><SPAN class="keyword">false</SPAN></CODE> を結果用引数 <CODE>B</CODE> で返します。 </P><P>補助のローカル手続き <CODE>And</CODE> も定義している事に注目して下さい。 </P><P></P><DIV class="figure" id="checkbintree"><HR><P><A name="checkbintree"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%&nbsp;二分木?<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">And</SPAN>&nbsp;B1&nbsp;B2&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;B1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;B2&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{And&nbsp;{BinaryTree&nbsp;T1}&nbsp;{BinaryTree&nbsp;T2}&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.6:</STRONG> 二分木のチェック</P><HR></DIV><P> </P><P><CODE>{And&nbsp;{BinaryTree&nbsp;T1}&nbsp;{BinaryTree&nbsp;T2}&nbsp;B}</CODE> の呼び出しを考えましょう。これは確かに必要のない仕事をしています。私達のネストのルールによると、それは最初の引数が <CODE><SPAN class="keyword">false</SPAN></CODE> なら2番目を評価します。最初の2つの引数を2つの手続きとして取る新しい手続き <CODE>AndThen</CODE> を作る事でこの問題を修正でき、それは最初のものが <CODE><SPAN class="keyword">false</SPAN></CODE> を返した場合のみ2番目を呼び出します; それゆえ、値が実際に必要になる時までその実行を遅延する事が出来ます。<A href="node5.html#checkbintreelazy">Figure&nbsp;5.7</A> に手続きを示します。<CODE>AndThen</CODE> は<EM>高階手続き(higher-order procedure)</EM>の最初の例です。高階手続きとは手続きを引数として取り、結果として手続きを返すかもしれない手続きの事です。この場合では、<CODE>AndThen</CODE> は単なるブール値を戻します。しかしながら、一般に、結果として手続きを返す手続きの例を見る事になります。関数型言語では、高階手続きは普遍的に再利用可能な部品を作るのに非常に重要な機構です。 </P><P></P><DIV class="figure" id="checkbintreelazy"><HR><P><A name="checkbintreelazy"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;{BP2}&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{AndThen<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;B1}&nbsp;{BinaryTree&nbsp;T1&nbsp;B1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;B2}&nbsp;{BinaryTree&nbsp;T2&nbsp;B2}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.7:</STRONG> 二分木を遅延的(lazily)にチェックする</P><HR></DIV><P> </P></DIV><DIV id="control.controlabs"><H2><A name="control.controlabs">5.9制御抽象(control abstraction)</A></H2><P>高階手続きは Oz で種々の制御抽象を定義するために使われます。モジュール <A href="../base/node12.html#chapter.control"><CODE>Control</CODE></A> と <A href="../base/list.html#section.records.lists"><CODE>List</CODE></A> や他の多くの中で、あなたは多くの制御抽象を目にするでしょう。いくつかのサンプルです。手続き <A href="../base/loop.html#section.control.loops"><CODE>{For&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}</CODE></A> は単項手続き(unary procedure) <CODE>P</CODE> (<CODE>P<SPAN class="keyword">/</SPAN>1</CODE> を一般にこう呼びます) の適用を <CODE>From</CODE> から <CODE>To</CODE> まで <CODE>Step</CODE> 間隔で繰り返し行う抽象です。<CODE>{For&nbsp;1&nbsp;10&nbsp;1&nbsp;Browse}</CODE> の実行は整数 <CODE>1&nbsp;2&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;10</CODE> を表示するでしょう。 </P><P></P><DIV class="figure" id="foriterator"><HR><P><A name="foriterator"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">HelpPlus</SPAN>&nbsp;C&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;C<SPAN class="keyword">=&lt;</SPAN>To&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{P&nbsp;C}&nbsp;{HelpPlus&nbsp;C<SPAN class="keyword">+</SPAN>Step&nbsp;To&nbsp;Step&nbsp;P}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">HelpMinus</SPAN>&nbsp;C&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;C<SPAN class="keyword">&gt;=</SPAN>To&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{P&nbsp;C}&nbsp;{HelpMinus&nbsp;C<SPAN class="keyword">+</SPAN>Step&nbsp;To&nbsp;Step&nbsp;P}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">For</SPAN>&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Step<SPAN class="keyword">&gt;</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{HelpPlus&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;{HelpMinus&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.8:</STRONG> For 反復</P><HR></DIV><P> </P><P>もう一つのよく使われる制御抽象は <CODE>ForAll<SPAN class="keyword">/</SPAN>2</CODE> 反復で <CODE>List</CODE> モジュールで定義されています。<CODE>ForAll<SPAN class="keyword">/</SPAN>2</CODE> は単項手続きをリスト中の全要素にリストで定義されている順に適用します。リストが他の並行スレッドによって漸増的に生成される場合に何が起こるか考えて下さい。この場合では消費者(consumer)スレッドはリストのデータが利用可能になるタイミングで同期するでしょう。リストは要素のストリームとして振る舞い、私達はスレッド間でのストリームコミュニケーションを自動的に手に入れます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ForAll</SPAN>&nbsp;Xs&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{P&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Xr&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.exception"><H2><A name="control.exception">5.10例外制御(exception handling)</A></H2><P>Oz は例外に対するかつ/または予測不可能な事態に対する安全防護プログラムを許す例外制御メカニズムを組み込んでいます。それはユーザ定義の例外を発生させ扱う事も可能です。 </P><P>例外はどんな式でも <I>E</I> です。例外 <I>E</I> を発生させるには、以下の文を実行します: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">raise</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>これはシンプルな例です: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Eval</SPAN>&nbsp;E}&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;E<BR>&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;&nbsp;&nbsp;plus(X&nbsp;Y)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;X<SPAN class="keyword">+</SPAN>Y}<BR>&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;&nbsp;&nbsp;times(X&nbsp;Y)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;X<SPAN class="keyword">*</SPAN>Y}<BR>&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;illFormedExpression(E)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>基本的な例外制御文は try 文と呼ばれます。その最もシンプルは形式は: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>この文の実行は <I>S1</I> が例外を発生させなければ <I>S1</I> を実行するという事と等価です。もし <I>S1</I> が例外 <I>E</I> を発生させれば、<I>X</I> は <I>E</I> に束縛され、文 <I>S2</I> が実行されます。変数 <I>X</I> は <I>S2</I> のスコープで可視です。 </P><P> より便利な try 文は以下になります: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_n</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>Sn</I><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> これは次に等しいです: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;X&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_n</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>Sn</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>言葉にすると、この文の実行は、 <I>S</I> が例外をあげなかった場合に <I>S</I> を実行する、という事に等しいです。もし <I>S</I> が例外 <I>E</I> を発生させたら <I>E</I> はパターン <I>Pattern_i</I> のうちの一つとマッチし、制御は対応する文 <I>S_i</I> に渡されます。もし <I>E</I> がどのパターンともマッチしなければ、例外は外側の try 文にキャッチされるまで伝播しつづけ、(それでもキャッチされなければ)最終的には漏れた全例外をキャッチするシステムによってキャッチされます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;[plus(5&nbsp;10)&nbsp;times(6&nbsp;11)&nbsp;min(7&nbsp;10)]&nbsp;Eval}<BR><SPAN class="keyword">catch</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;illFormedExpression(X)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'**&nbsp;'</SPAN><SPAN class="keyword">#</SPAN>X<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;**'</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>try 文は、正常終了でも例外発生終了でも実行される最後の文 <I>S_final</I> を指定する事が出来ます。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_n</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>Sn</I><CODE>&nbsp;<BR><SPAN class="keyword">finally</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>S_final</I><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE>F</CODE><A href="node5.html#label40"><SUP>3</SUP></A> は開かれたファイルと仮定して下さい; 手続き <CODE>Process<SPAN class="keyword">/</SPAN>1</CODE> はファイルをいくつかの方法で操作します; そして手続き <CODE>CloseFile<SPAN class="keyword">/</SPAN>1</CODE> はファイルを閉じます。以下のプログラムは <CODE>F</CODE> が正常終了でも例外発生終了でも閉じられる事を保証します。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;{Process&nbsp;F}<BR><SPAN class="keyword">catch</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'**&nbsp;'</SPAN><SPAN class="keyword">#</SPAN>X<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;**'</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">finally</SPAN>&nbsp;{CloseFile&nbsp;F}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.sysexcept"><H2><A name="control.sysexcept">5.11システム例外(system exception)</A></H2><P>Oz システムによって発生した例外は次のラベルによって記録されます: <CODE>failure</CODE>, <CODE>error</CODE>, <CODE>system</CODE> </P><P></P><UL><LI><P><CODE>failure</CODE>: Oz にストアされた値と整合性を持たない同等性操作を行おうとした事を示します。 </P></LI><LI><P><CODE>error</CODE>: 手続きでないものを引数に適用しようとしたり整数をアトムに足そうとしたりといった起こるべきでない実行時エラーを示します。 </P></LI><LI><P><CODE>system</CODE>: Mozart オペレーティングシステムプロセスの実行時の状況を示します。閉じられたファイルやウィンドウ、2つの Mozart プロセス間の接続の失敗の様な予測不可能な状況。 </P></LI></UL><P> </P><P>以下の例はどうやってラベルのみによって failure 例外の発生をキャッチするかのデモンストレーションです。これは実装の詳細にあまり依存しない推奨される方法です。 </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">One</SPAN>&nbsp;X}&nbsp;X=1&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Two</SPAN>&nbsp;X}&nbsp;X=2&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">try</SPAN>&nbsp;{One}={Two}<BR><SPAN class="keyword">catch</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;failure(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;caughtFailure}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>ここでパターン <CODE>failure(<SPAN class="keyword">...</SPAN>)</CODE> は全てのラベルが <CODE>failure</CODE> である全てのレコードをキャッチしています。例外が発生しても制御されない時、エラーメッセージが emulator ウィンドウ(standard error)に印字され、現在のスレッドは終了します。スタンドアロンなアプリケーションではデフォルトの動作は標準のエラーでメッセージが印字され、全アプリケーションが終了します。個々のアプリケーションのためにこの動作をより多くの記述を行うように変更する事が出来ます。 </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.equality">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.functional">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label38">1. </A>このルールは付属的なものです、なぜならクラスメソッドとパターンが発生の識別と束縛されるための。</DIV><DIV class="footnote"><A name="label39">2. </A>実際にはエクスクラメーションマーク <CODE><SPAN class="keyword">!</SPAN></CODE> は新しい変数を抑制したい他の状況でも使えます、例えばパターンマッチ構築の様な。</DIV><DIV class="footnote"><A name="label40">3. </A>後でどの様に input/output が扱われるかを見ましょう。</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
