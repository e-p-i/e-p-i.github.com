<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><TITLE>1 Introduction</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.opi">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.introduction"><H1><A name="chapter.introduction">1 Introduction</A></H1><P>Mozart システムは、並行制約モデル基づいたマルチパラダイム言語である Oz ファミリーの最新版である Oz 3 を実装しています。Oz 3 は Oz 2 のほぼ完全な上方互換です。Oz 2 からの主要な追加物はファンクタ(functor ソフトウェアコンポーネントの一種)とフューチャ(future 改良されたデータフローの振る舞い)です。Oz 2 はオリジナルの Oz 1 言語の後継で、その最初の実装は1995年に公開されました。ここ以外で明記はしませんが、Mozart の文書での Oz への参照は全て Oz 3 に対するものです。 </P><P>Oz 3 と Mozart システムは DFKI (the German Research Center for Artificial Intelligence) の Gert Smolka、SICS (the Swedish Institute of Computer Science) の Seif Haridi、 UCL (the Universit� catholique de Louvain) の Peter Van Roy 達による研究者のグループを主として開発されてきました。 </P><P>全ての Oz のバージョンは並行制約プログラミングモデルを基礎としており、ステートフルな計算、つまり破壊的代入可能(mutable)なオブジェクトによる計算をサポートするよう拡張されています。並行制約モデルの理論的基礎は <A href="bib.html#saraswat94">[Sar94]</A> を参照して下さい。オリジナルの Oz の計算モデルである Oz 1 は各ステートメント(statement 文)が潜在的に並行に実行される細粒度(fine-grained)の並行性の概念をサポートします。この細粒度のモデルでの実行結果はアクター(actor)モデルに似ています。Oz 1 プログラミングモデルへの一つの良い解説は <A href="bib.html#smolka95">[Smo95]</A> を参照して下さい。我々が Oz 1 を使ってみた経験から、この種のモデルは理論的には魅力的であるものの、プログラマがアプリケーションの資源をコントロールするのを非常に難しくしてしまう事が分かりました。プログラムのデバッグをするのは非常に難しく、オブジェクトのモデルは不必要に複雑でした。 </P><P>Oz 2 は代わりに明示的なスレッド生成を用いたスレッドベースの並行モデルでこれらの問題の対処を行いました。パワフルな新しいオブジェクトシステムが設計され、伝統的な例外制御構造が加えられました。加えて、制約解決(constraint solving)と探索(search)能力が大幅に強化されました。 </P><P>Oz 3 は Oz 2 に<EM>ファンクタ(functor)</EM>と<EM>フューチャ(future)</EM>の2つのコンセプトを伴った保守的な拡張であり、いくつかの構文的な問題を修正したものです。ファンクタはソフトウェアコンポーネントの類です。それは必要とする他のモジュールを指定します。これはURL経由で紐付け可能であるかもしれないコンポーネントからプログラムの漸増的(incremental)な構築を行う事をサポートします。<A href="bib.html#duchier98">[Duc98]</A>を参照。フューチャは読み込み可能で書き込み不可能な論理変数(logic valiable)です。これによりインターネット経由の安全なデータフローの同期が許されます。 </P><P>Mozart システムは分散•ネットワーク化されたアプリケーションをサポートします。異なるサイト(site)上に位置する Oz の計算に接続する事が可能であり、ネットワーク透過な計算として結果が返ってきます。Mozart はサイト、可搬な計算(mobile computation)とオブジェクト、メッセージパッシング(message passing)、共有論理変数、ネットワークとサイトのための失敗検知•制御用の直行するメカニズムの中で、ステートレスなデータとコードの自動的な転送をサポートします。 </P><H2><A name="label1">1.1Oz の特徴のまとめ</A></H2><P>「なぜ Oz なのか？」と問う事はとても良いスタート地点です。そうですね、その一つの短い答えは、「他にある言語と比べると、それは魔法である！」という事です。それはプログラマとシステム開発者に、複雑なアプリケーションを素早く頑健(robustly)に開発する事を可能にする広範囲のプログラミング抽象(programming abstraction)を提供します。Oz は複数のプログラミング言語のデザインの方向性を一つの整合性のあるデザインに併合しています。私達のほとんどは、オブジェクト指向型、関数型、制約論理型の様な異なるプログラミングパラダイムの利点を知っています。私達がどの既存の言語でプログラムを書き始める時も、基礎となっているパラダイムのコンセプトに私達自身が閉じ込められている事にすぐに気付きます。Oz はこの問題を異なるパラダイムのプログラミング抽象をクリーンかつシンプルな方法で組み合わせた整合性のあるデザインによって解決します。 </P><P>上述の質問に答える前に、Oz とはどんなものなのかを見てみましょう。これはまたもや難しい質問で、短い言葉では答えが出せません。まずアプローチとしてファーストショットを打ちます。Oz は、現代的先進的、並行、知的、ネットワーク化、ソフトリアルタイム、並列、インタラクティブで予見的(pro-active)なアプリケーションのためにデザインされた高レベルなプログラミング言語です。見ての通り、これら全てのジャーゴンが意味するところを知るのは依然として難しいです。より具体的には: </P><UL><LI><P>Oz は、状態、抽象データ型、クラス、オブジェクト、継承を提供する事によりオブジェクト指向プログラミングの顕著な特徴を組み合わせています。 </P></LI><LI><P>Oz は、構文の組み合わせ、第一級の手続き、レキシカルスコープを提供する事により関数型プログラミングの顕著な特徴を提供しています。実際、Oz の全てのエンティティ(entity 実体)は、手続き、スレッド、クラス、メソッド、オブジェクトを含んでいて、第一級のクラスとなっています。 </P></LI><LI><P>Oz は、論理変数、選言的構築(disjunctive constructs)、プログラム可能な探索戦略を提供する事により論理型プログラミングと制約型プログラミングの顕著な特徴を提供しています。 </P></LI><LI><P>Oz は、ユーザが動的に相互にやり取りが出来る一貫したスレッドをいくつも生成出来る並行言語です。しかしながら、保守的な並行言語と対照的に、各 Oz のスレッドはデータフロースレッドとなっています。Oz の1ステートを実行する時は、そこに関係する全ての<EM>実際の</EM>データフローの依存が解決された時にのみ、計算が進みます。 </P></LI><LI><P>Mozart システムはネットワーク透過で分散した Oz の計算をサポートします。複数の Oz のサイトは相互に接続して自動的に単一の Oz の計算、共有変数、オブジェクト、クラス、手続きであるかの様に揺る舞います。サイトは、異なるサイト間のエンティティの参照が途絶えた時には、自動的に切断します。 </P></LI><LI><P>分散環境の Oz では言語レベルのセキュリティが提供されます。これは、全ての言語のエンティティは明示的に生成され渡されるという事です。アプリケーションは明示的に権利が与えられていない限り、参照を偽造したり参照にアクセスしたり出来ません。言語のエンティティを基礎として表現されているものはプログラマにはアクセス不可能です。これは抽象ストアとレキシカルスコーピングの結果です。第一級の手続きと一緒に、これらのコンセプトは、オープンな分散コンピューティングに重要である実行可能ベース(capability-based)のセキュリティポリシーを実装するために必須なものです。 </P></LI></UL><P> </P><H2><A name="label2">1.2核言語(kernel language)</A></H2><P>このセクションでは Oz 核言語について短いですが適切な導入を与えます。Oz 言語の全体は、小さな核言語への構文糖衣と見なせます。核言語は、言語の必須の部分を表します。 </P><P></P><DIV class="figure" id="corelang"><HR><P><A name="corelang"></A></P></DIV><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>Statement</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>Statement1</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>Statement2</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE><I>f</I><CODE>(</CODE><I>l1</I><CODE>:</CODE><I>Y1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>ln</I><CODE>:</CODE><I>Yn</I><CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE>&lt;<I>number</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE>&lt;<I>atom</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE>&lt;<I>boolean</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{NewName&nbsp;</CODE><I>X</I><CODE>}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE><I>Y</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">local</SPAN>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Xn</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{</CODE><I>X</I><CODE>&nbsp;</CODE><I>Y1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Yn</I><CODE>}&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{X&nbsp;</CODE><I>Y1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Yn</I><CODE>}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{NewCell&nbsp;Y&nbsp;X}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>Y=<SPAN class="keyword">@</SPAN>X</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>X<SPAN class="keyword">:=</SPAN>Y</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{Exchange&nbsp;X&nbsp;Y&nbsp;Z}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;</CODE><I>X</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">raise</SPAN>&nbsp;</CODE><I>X</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;1.1:</STRONG> Oz 核言語</P><HR></DIV><P> </P><P>Oz の実行モデルは共有ストアを監視するデータフロースレッドから成ります。スレッドは文(statement)の連なり(sequences) <I>Si</I> を含み、ストア中の共通参照を通してやり取りをします。文が必要とする全ての値が利用可能な時のみ次の文を実行する場合、スレッドは<EM>データフロー(dataflow)</EM>です。文が必要とする値がまだ利用可能出ない場合、スレッドは値がアクセス可能になるまで自動的にブロックします。私達が見るように、Oz モデルでのデータの利用性(availability)は論理変数を使って実装されています。共有ストアは物理メモリではなく、関係するエンティティに関して適正な操作のみを許可する抽象ストアです、すなわち、エンティティの内部表現を推測する直接的な方法はありません。ストアは未束縛と束縛済みの論理変数、セル(cell 代入可能なポインタ、すなわち明示的な状態)、手続き(第一級のエンティティであるレキシカルスコープのクロージャ)を含みます。変数は手続きとセルの名前を参照出来ます。セルは変数を指します。外部の手続きの参照は変数です。変数は束縛された時に消えます、つまり、その変数を参照していた全スレッドは代わりとして自動的にその束縛を参照するようになります。変数は他の変数を含む全エンティティと束縛出来ます。変数と手続きのストアは単調、すなわち、情報は追加されるのみであり変更されたり除去されたりしません。 </P><P><A href="node1.html#corelang">Figure&nbsp;1.1</A> 核言語での文Sの抽象構文の決定私達は可能な限り簡単にそれぞれの文を定義します。文の連なりはスレッド中で連続的(sequentially)に結果に帰着(reduce)します。値(レコード、数値、etc)は明示的に導入され、変数と同じように見なされます。全ての変数は、<CODE><SPAN class="keyword">local</SPAN></CODE>文で定義された明示的なスコープで宣言された論理変数です。手続きは実行時に<CODE><SPAN class="keyword">proc</SPAN></CODE>文で定義され、変数によって参照されます。手続き適用(procedure application)は最初の実引数が手続きを参照するまでブロックします。状態は変数ストアへの更新可能なポインタであるセルを生成する <EM>NewCell</EM> によって明示的に作られます。セルは <CODE><SPAN class="keyword">@</SPAN></CODE> によって読まれ <CODE><SPAN class="keyword">:=</SPAN></CODE> または <EM>Exchange</EM> によって更新されます。条件はキーワード <CODE><SPAN class="keyword">if</SPAN></CODE> を使い、それは選択用の変数 <I>B</I> が変数ストア中で <CODE><SPAN class="keyword">true</SPAN></CODE> か <CODE><SPAN class="keyword">false</SPAN></CODE> になるまでブロックします。スレッドは <CODE><SPAN class="keyword">thread</SPAN></CODE> 文によって明示的に生成されます。例外制御は動的スコーピングで <CODE><SPAN class="keyword">try</SPAN></CODE> と <CODE><SPAN class="keyword">raise</SPAN></CODE> 文を使います。 </P><P>Oz の全言語は全ての文をこの核言語に変換する事で定義されます。これはこの文書で詳細に説明されるでしょう。Oz はオブジェクト、クラス、再入可能ロック、ポートの様なイディオムをサポートします。 <A href="bib.html#smolka95">[Smo95]</A><A href="bib.html#pvr97">[VR97]</A>. システムは定義を尊重しながら効率的にそれらを実装します。導入として、私達はそれらイディオムの定義の簡単なまとめを与えるでしょう。明瞭さのために、現段階では小さな概念的簡略化を行います。完全な定義はこの文書の後の方で与えられます。 </P><H2><A name="label3">1.3クラス(class)</A></H2><P>クラスは基本的にメソッドテーブル(method table)と属性(attributte 訳注:クラスで定義されている変数の事)の名前を含むレコードです。クラスは複数の継承を通して定義され、メソッドテーブルを構築する時に全ての衝突が解決されます。 </P><H2><A name="label4">1.4オブジェクト(object)</A></H2><P>オブジェクトは基本的にいくつものコンポーネントを持つ特別なレコードです。1つのコンポーネントはオブジェクトのクラスです。他のコンポーネントはセルを参照する1引数の手続きで、それはレキシカルスコープで隠蔽されています。セルはオブジェクトの状態を保持しています。オブジェクト <CODE>Obj</CODE> をメッセージ <CODE>M</CODE> に適用するとは、オブジェクトの手続きを <CODE>M</CODE> に適用する事です。引数はメソッドテーブルに順序付けられます。メソッドは状態セルへの参照が与えられた手続きです。通常それはオブジェクトの状態を更新します。 </P><H2><A name="label5">1.5再入ロック(reentrant lock)</A></H2><P>再入ロックは、オブジェクト中のメソッドが並行に使われるような場合に、明示的な状態変更の実行のために使われる1引数の手続き <CODE>{Lck&nbsp;P}</CODE> です。再入ロックは動作のためにセルと論理変数を使います。<CODE>P</CODE> はクリティカルセクションを定義する0引数の手続きです。再入とは同じスレッドがロック部分に再び入る事が許可されている事を意味します。それゆえロックの呼び出しはネストされるかもしれません。ロックは該当部のスレッドが終了するか例外を発生させる事でロック部分から抜ける事により自動的に開放されます。 </P><H2><A name="label6">1.6ポート(port)</A></H2><P>ポートはN:1のコミュニケーションをサポートする非同期チャネルです。ポート <CODE>P</CODE> はストリーム <CODE>S</CODE> をカプセル化します。ストリームは末尾が束縛されていないリストのことです。操作 <CODE>{Send&nbsp;P&nbsp;M}</CODE> は <CODE>M</CODE> を <CODE>S</CODE> の最後に加えます。同じスレッドからの連続した送信は送られた順番に表れます。 </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.opi">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franz�n</A><BR><SPAN class="version">Version 1.4.0 (20080704)</SPAN></ADDRESS></BODY></HTML>
